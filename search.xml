<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【讲课】8.4计数]]></title>
    <url>%2F%E3%80%90%E8%AE%B2%E8%AF%BE%E3%80%918-4%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[菊开讲课，必属精品！T1题意小 $\text{A}$ 会投 $a$ 次硬币，小 $\text{B}$ 会投 $b$ 次硬币，求有多少种情况，小 $\text{A}$ 投出的硬币正面向上的次数严格大于小 $\text{B}$ 投出的硬币正面向上的次数，答案保留最后 $k$ 位$1\leqslant a,b\leqslant10^{15}$ , $b\leqslant a\leqslant b+10000$ , $1\leqslant k\leqslant9$题解设 $x$ 为小 $\text{A}$ 投出的向上的次数，设 $y$ 为小 $\text{B}$ 投出的向下的次数。有 $x+y&gt;b$ ，枚举 $x+y$答案即是 $\sum_{i=b+1}^{a+b}{\binom{a+b}{i}}$T2题意求 $n$ 个点 $m$ 条边的无向连通图的个数，点有标号$n\leqslant30$ , $m\leqslant100$题解设 $f_{i,j}$ 表示 $i$ 个点 $j$ 条边的无向连通图，枚举与 $1$ 相连的连通块转移$f_{i,j}=\binom{\frac{i(i-1)}{2}}{j}-\sum_{x=1}^{i}{\sum_{k=0}^{j}{f_{x,k}\times\binom{\frac{(i-x)(i-x-1)}{2}}{j-k}\times\binom{n-1}{x-1}}}$T3题意给定一个 $n$ 个点的图，初始时没有边每次随机选择两个不相同的点连接起来求期望要多少次才能使整个图连通$n\leqslant30$题解考虑到 $30$ 的拆分数只有 $5600$ 左右，可以直接将图的连通情况作为状态，然后 $O(n^2)$ 转移T4题意给出一个 $n$ 个点 $m$ 条边的无向图，每条边的权值不固定，为 $[0,1]$ 内的随机变量，无重边无自环，求最小生成树上最大边的期望边权$n\leqslant10$ , $m\leqslant\frac{n(n-1)}{2}$题解设 $f_{s,i}$ 表示连通块 $s$ 里连了 $i$ 条边的方案数设 $g_{s,i}$ 表示在点集 $s$ 里连了 $i$ 条边且不连通的方案数暂咕[SHOI2017] 分手是祝愿题面题目链接Zeit und Raum trennen dich und mich.时空将你我分开。$\text{B}$ 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为 $1\sim n$ 的正整数。每个灯有两个状态亮或灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$ ）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。$\text{B}$ 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。这个策略需要的操作次数很多， $\text{B}$ 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。$\text{B}$ 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。这个期望可能很大，但是 $\text{B}$ 君发现这个期望乘以 $n!$ 一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。$n\leqslant100000$题解设 $f_i$ 为从还剩 $i$ 个位置到还剩 $i-1$ 个位置的期望步数暂咕T6题意在一个直角坐标系上依次插入 $n$ 个点，每次插入之后输出当前有多少个三角形严格覆盖原点。（强制在线）$n\leqslant100000$题解考虑一个不合法的方案，对一个极角最小的点，另两个点一定在原点到该点连线的半平面内用平衡树维护即可T7题意“奋战三星期，举重五百斤”，一大群鸽子来到了 $\text{CJ}$ 的健身房，发现房间里有一排共 $n$ 个铁饼。有 $Q$ 次操作，你需要支持三种操作：1 x y 将第 $x$ 个铁饼的重量设置为 $y$2 L R 翻转第 $L$ 至第 $R$ 个铁饼3 L R W 询问仅使用 $L$ 到 $R$ 之间的铁饼能否拼出一个重量为 $W$ 的杠铃鸽子们还在健身房的天花板上发现了一个数字 $k$ 。机智的它们立刻发现，在任意时刻出现过的不同的铁饼数目是不会超过 $k$ 的。$n,Q,W\leqslant100000$ , $k\leqslant10$题解[HAOI2008]硬币购物暂咕T8题意给你一个长度为 $n$ 的序列 $A$ ，如果 $n$ 不是非降，你必须删掉一个数，直到非降为止，求不同方案数，对 $1000000007$ 取模。$n\leqslant2000$题解设 $f_i$ 表示删到长度为 $i$ 的非降序列的方案数（包含不合法）预处理 $g_i$ 为长度为 $i$ 的非降序列的个数$f_i=g_i\times(n-i)!$从小到大容斥掉不合法的方案T9题意给你一个长度为 $2n$ 的序列 $a$ ，其中有些位置上的元素是 $-1$ ，保证 $1\sim 2n$ 最多只出现一次，定义一个长度为 $n$ 的数组 $b$ ， $b_i=\min(a_{2i-1},a_{2i})$ ，求有多少种不同的 $b$ 数组。$n\leqslant300$题解把 $a$ 分成 $n$ 个二元组，则每个二元组只有 $3$ 种情况$f_{i,j,k}$ 表示从大往小考虑到第 $i$ 个数，有 $j$ 个 $(-1,x)$ ，有 $k$ 个 $(-1,y)$ 。（ $y$ 为已经填进去的）暂咕T10题意给定一个长度为 $n$ 的正整数序列 $a$求有多少个长度为 $n$ 的正整数序列 $x$ 满足对于任意 $1\leqslant i\leqslant n$ , $1\leqslant x_i\leqslant D$对于任意 $1\leqslant i&lt;j\leqslant n$ , $\max(a_i,a_j)&lt;|x_i-x_j|$$n\leqslant50$ , $a_i\leqslant40$题解按 $a_i$ 排序依次插入设 $f_{i,j,s}$ 表示插入到第 $i$ 个，还有 $j$ 个缝隙，压紧后长度为 $s$ 的方案数枚举第 $i$ 个是放在两端还是合并两个已有段转移T11题意给定一个长度为 $n$ 的整数序列 $S$求有多少个长度为 $n$ 的正整数序列 $T$使得将 $S$ 和 $T$ 排序后， $S$ 的每一位都不小于 $T$ 的每一位$n\leqslant1000$题解对 $S$ 和 $T$ 排序设 $f_i$ 表示有多少个 $T$ 的前 $i$ 位满足条件枚举第一个不满足条件的位置，用总方案减去不满足的转移]]></content>
      <tags>
        <tag>讲课</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试】8.3模拟考试]]></title>
    <url>%2F%E3%80%90%E8%80%83%E8%AF%95%E3%80%918-3%E6%A8%A1%E6%8B%9F%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[校内资料，请输入密码访问 (*╹▽╹*) Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【讲课】8.2网络流]]></title>
    <url>%2F%E3%80%90%E8%AE%B2%E8%AF%BE%E3%80%918-2%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[菊开讲课，必属精品！[bzoj1280] $\text{Emmy}$卖猪pigs题面题目链接$\text{Emmy}$ 在一个养猪场工作。这个养猪场有 $m$ 个锁着的猪圈，但 $\text{Emmy}$ 并没有钥匙。有 $n$ 个顾客会到养猪场来买猪，一个接着一个。每一位顾客都会有一些猪圈的钥匙，他们会将这些猪圈打开并买走固定数目的猪。所有顾客有的钥匙和他们需要买猪的数量在事先都告诉了 $\text{Emmy}$，于是 $\text{Emmy}$ 要订一个计划，使得卖出去的猪最多。买卖的过程是这样的：一个顾客前来，并打开所有他可以打开的猪圈。然后 $\text{Emmy}$ 从这些猪圈里牵出固定数目的猪卖给顾客（最多只能和顾客需要数相等），并可以重新安排这些开着的猪圈中的猪。每个猪圈可以存放任意数目的猪。写一个程序，使得 $\text{Emmy}$ 能够卖出去尽可能多的猪。$n\leqslant100$ , $m\leqslant1000$题解暂咕[bzoj2406] 矩阵题面题目链接给定一个整数矩阵 $A[n\times m]$ ，求一个矩阵 $B[n\times m]$ 满足 $\forall1\leqslant i\leqslant n,1\leqslant j\leqslant m,B_{ij}\in[L,R]$ ，且使下式值最小：\large max= \begin{cases} \mathop{max}\limits_{1\leqslant j\leqslant m} \{|\sum_{i=1}^{n}{(A_{ij}-B_{ij})}|\}\\ \mathop{max}\limits_{1\leqslant i\leqslant n} \{|\sum_{j=1}^{m}{(A_{ij}-B_{ij})}|\} \end{cases}$n,m\leqslant 200$题解暂咕[TJOI2015] 组合数学题面题目链接为了提高智商， $\text{ZJY}$ 开始学习组合数学。某一天她解决了这样一个问题：给一个 $n\times m$ 的网格图，其中某些格子有财宝。每次从左上角出发，只能往右或下走。问至少要走几次才可能把财宝全捡完。但是她还不知足，想到了这个问题的一个变形：假设每个格子中有好多块财宝，而每一次经过一个格子至多只能捡走一块财宝，其它条件不变，至少要走几次才可能把财宝全捡完？这次她不会做了，你能帮帮她吗？$n,m\leqslant1000$题解最长链等于最少反链覆盖每个点向不能到达它的点连边，跑最长路[bzoj1189] 紧急疏散evacuate题面题目链接发生了火警，所有人员需要紧急疏散！假设每个房间是一个 $n\times m$ 的矩形区域。每个格子可以是空地、墙或者门，人们可以从门撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。$3\leqslant n,m\leqslant20$题解对时间建分层图[POI2010] Bridges题面题目链接$\text{YYD}$ 为了减肥，他来到了瘦海，这是一个巨大的海，海中有 $n$ 个小岛，小岛之间有 $m$ 座桥连接，两个小岛之间不会有两座桥，并且从一个小岛可以到另外任意一个小岛。现在 $\text{YYD}$ 想骑单车从小岛 $1$ 出发，骑过每一座桥，到达每一个小岛，然后回到小岛 $1$ 。霸中同学为了让 $\text{YYD}$ 减肥成功，召唤了大风，由于是海上，风变得十分大，经过每一座桥都有不可避免的风阻碍 $\text{YYD}$ ， $\text{YYD}$ 十分 $ddt$ ，于是用泡芙贿赂了你，希望你能帮他找出一条承受的最大风力最小的路线。$2\leqslant n\leqslant1000$ , $1\leqslant m\leqslant2000$题解二分答案，网络流检验先随机定向，检查每个点的度数对于一个点入度减出度为正的，源点向其连边，否则该点向汇点连边边权为度数差的绝对值[bzoj4213] 贪吃蛇题面题目链接最近 $\text{lwher}$ 迷上了贪吃蛇游戏，在玩了几天却从未占满全地图的情况下，他不得不承认自己是一个弱菜，只能改去开发一款更弱的贪吃蛇游戏。在开发的过程中， $\text{lwher}$ 脑洞大开，搞了一个多条蛇的模式。但由于这种模式太难操作，于是他只好改变游戏的玩法，稍微变化一下游戏目标。新的游戏是这样的：一些蛇覆盖了一个网格。每个格子要么是一个障碍物，要么是蛇的一部分。每条蛇占据了一条折线（拐角处只能水平和竖直连接），且至少占据两个格子。蛇与蛇之间不能重叠，蛇也不会与自己重叠。每条蛇还必须满足以下两个条件中的一个：两个端点所在的格子在网格的边界。蛇构成一个环，即两个端点相邻（垂直或水平，不能斜着），至少要占据 $4$ 个格子（否则没法形成环）。给定一个网格，在满足前面所述的条件下覆盖所有空地，并使得端点在网格边界（即不构成环）的蛇尽量少。（如果一条蛇既构成环，又是端点在边界，那么不计入答案）例如，以下网格：可以由下面三种方案覆盖。还有其它的方案，但是没法仅用一条不构成环的蛇就覆盖整个网格。$n,m\leqslant12$题解黑白染色，边界的点下界为 $1$ ，上界为 $2$内部的点上下界皆为 $2$ ，障碍不连边[CEOI2008] order题面题目链接有 $n$ 个工作， $m$ 种机器，每种机器你可以租或者买过来。每个工作包括若干道工序，每道工序需要某种机器来完成，你可以通过购买或租用机器来完成。现在给出这些参数，求最大利润。$1\leqslant n,m\leqslant1200$题解源点向工作连收益工作向机器连租的价格机器向汇点连买的价格用总收益减去最小割[bzoj3774] 最优选择题面题目链接小 $\text{N}$ 手上有一个 $n\times m$ 的方格图，控制某一个点要付出 $A_{ij}$ 的代价，然后某个点如果被控制了，或者它周围的所有点（上下左右）都被控制了，那么它就算是被选择了的。一个点如果被选择了，那么可以得到 $B_{ij}$ 的回报。现在请你帮小 $\text{N}$ 选一个最优的方案，使得回报减代价尽可能大。$n,m\leqslant 50$题解暂咕T9题意$p\times q$ 的网格，每个位置有 $r$ 种选择，编号为 $1\sim r$ ，每种选择都有对应收益（可能为负）限制每个点分别和它上下左右相邻的 $4$ 个点的选择编号之和不能超过 $d$最大化总收益$p,q,r\leqslant40$题解暂咕]]></content>
      <tags>
        <tag>讲课</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu3383]线性筛素数]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu3383-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[此处题面前言首先说一下，这个科技是我在 $\text{Min_25}$ 的博客里看见的，那篇博客是 $2017$ 年的了，去翻了下提交记录发现论文哥也用了这个科技，所以也并不是什么新东西。有兴趣的也可以去阅读一下那篇博客。然后，虽然这个题是线性筛素数，但是这篇题解并不是讲筛法的，而是一些奇技淫巧。若是想学习素数筛法的可以跳过这篇题解了。正文相信各位都知道一个 $O(\sqrt n)$ 判断素数的方法，也就是枚举 $2\sim\lfloor\sqrt n\rfloor$ 检查每个数是否是 $n$ 的约数。具体代码如下：123456bool check(int x) &#123; if(x==0||x==1) return false; for(int i=2;i*i&lt;=x;++i) if(x%i==0) return false; return true;&#125;这个题我们只要对于每个询问都这样判断一次即可，复杂度上界 $O(M\sqrt N)$ 。如果我的数据是 $10^6$ 个 $9840769$ ，并且你的程序没有记忆化，这个程序需要 $\text{7.7s}$ 左右的时间才能出解。我们考虑怎样优化。我们判断约数的时候需要取模，而众所周知 $\text{C++}$ 的取模是很慢的，如果能加快取模的效率，就能对运行速度有很大优化。$\text{Min_25}$ 在他的博客里讲到了这样一种优化方法：考虑到判断约数时我们只需要得知取模结果是否为 $0$ ，并不需要知道实际结果。若 $m$ 为奇数， $m’$ 为 $m$ 模 $2^{64}$ 下的逆元，且有 $n\in\left[0,2^{64}\right)$ ，则：n\equiv0\pmod{m}\ \Leftrightarrow\ (n\cdot m')\%2^{64}\leqslant\lfloor\frac{2^{64}}{m}\rfloor对于一个模数 $m$ 我们预处理出 $m’$ 和 $\lfloor\frac{2^{64}}{m}\rfloor$ ，然后我们就可以把判断 $n\%m$ 是否为 $0$ 转化为一次乘法和一次比较大小。使用这个方法，刚刚跑 $\text{7.7s}$ 的程序只需要 $\text{1.9s}$ 即可出解， $4$ 倍的效率优化！最后这个技巧不仅可以用于判断素数，也可以用于质因数分解，杜教筛、洲阁筛、 $\text{Min_25}$ 筛的预处理。但使用场合还是较少，不过效率优化还是十分明显的！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【更新中】浅谈模意义下形式幂级数的几种操作]]></title>
    <url>%2F%E3%80%90%E6%9B%B4%E6%96%B0%E4%B8%AD%E3%80%91%E6%B5%85%E8%B0%88%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E5%BD%A2%E5%BC%8F%E5%B9%82%E7%BA%A7%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[目录[ ] 多项式乘法[ ] 快速傅里叶变换[x] 单位根[x] DFT[x] IDFT[ ] 优化[x] 三次变两次[ ] $\text{MTT}$ （暂咕）[ ] 快速数论变换[x] 原根[ ] 预处理原根[ ] 多项式求逆[ ] 分治 $\text{FFT}$[ ] 多项式开根[ ] 多项式求导/积分[ ] 多项式 $Ln$[ ] 多项式反三角函数[ ] 多项式 $Exp$[ ] 多项式快速幂[ ] 多项式三角函数[ ] 多项式除法/取模[ ] 多项式多点求值[ ] 多项式快速插值前言近几年信息学竞赛中出现了一类利用 生成函数 进行计数的题目，这类题目往往需要一顿推导之后得出一个或几个容易计算的生成函数与代表答案的生成函数间的关系。由于这类题目往往需要将结果对一个大质数取模，因此我们可以用模意义下形式幂级数的一些操作来进行这些生成函数之间的运算。本文将从简单的离散傅里叶变换开始，逐步带你了解这一类基于离散卷积的形式幂级数操作。你需要知道的几点多项式由数或字母或两者的乘积组成的代数式叫单项式（单个数或字母也为单项式）单项式中的常数因子为单项式的系数单项式中所有字母的指数之和为单项式的次数由若干个单项式相加组成的代数式叫多项式多项式各项中次数最大的单项式的次数为多项式的次数形式幂级数定义域为 $\mathbb Z^+$ 或其有限子集的函数叫数列（也就是一些有序的数）将数列的每一项求和得到的函数叫级数，一般所讲的级数大多指无穷级数，即数列有无穷项形如 $\sum_{i=0}^{\infty}{a_i(x-x_0)^i}$ 的级数叫幂级数（ $x_0$ 为常数）其中 $a_i$ 为幂级数的系数（可以类比多项式的各项系数）若存在一个非负实数 $r$ 使得幂级数在 $ | x - x_0 | &lt; r $ 时趋近于一个确定的值（收敛），在 $ | x - x_0 | &gt; r $ 时不趋于任何值（发散），则称 $ r $ 为幂级数的收敛半径，否则称该幂级数的收敛半径为 $ +\infty $将一个数列的各项作为幂级数的系数，所得到的幂级数不一定是收敛的（收敛半径可能为 $0$ ）。但我们淡化其收敛与发散的性质，认为它是收敛的，则可以得到一个形式上类似幂级数的东西（也就是长得像幂级数），我们将其称为形式幂级数若一个形式幂级数从某一项开始，后面项的系数全部为 $0$ ，则我们称其为形式多项式离散卷积令 $f(x)$ 和 $g(x)$ 为定义在 $\mathbb R$ 上的两个可积函数，则称 $\int_{-\infty}^{\infty}{f(\tau)g(x-\tau)d\tau}$ 关于 $x$ 的函数为 $f(x)$ 与 $g(x)$ 的卷积与卷积类似，我们称数列 $c_n=\sum_{i=-\infty}^{\infty}{a_ib_{n-i}}$ 为数列 $a_n$ 与数列 $b_n$ 的离散卷积形式幂级数与幂级数一样可以进行运算，其加减运算即是将对应位的系数相加减，而其乘法运算结果定义为两个形式幂级数系数的离散卷积构成的形式幂级数形式幂级数存在乘法逆元当且仅当 $a_0\ne0$ ，且若存在，则逆元唯一后面的形式幂级数运算若无特殊说明，全部在 $\pmod{x^{n+1}}$ 意义下进行，也即为形式多项式记号与约定我们记以数列 $\{f_n\}$ 为系数的形式幂级数为 $F(x)$ 。我们记 $[x^n]F(x)$ 为 $F(x)$ 的 $n$ 次项系数。我们记 $f_ig_i$ 为 $f_i\times g_i$ ，而 $F(x)G(x)$ 为 $F(x)$ 与 $G(x)$ 的离散卷积。多项式乘法快速傅里叶变换我们知道，两个形式幂级数做乘法即为它们系数的离散卷积。假设我们已知 $F(x)$ 和 $G(x)$ 的系数，我们要求得 $H(x)=F(x)G(x)$根据定义：h_n=\sum_{i=0}^{n}{f_ig_{n-i}}\Rightarrow H(x)=\sum_{i=0}^{\infty}{\sum_{j=0}^{i}{f_jg_{i-j}x^i}}很显然，我们求出 $H(x)$ 一项的时间复杂度是 $\Theta(n)$ 的，求出 $n$ 项的时间复杂度是 $\Theta(n^2)$ 的，这肯定是不能接受的。我们来考虑怎样更快速地求得 $H(x)$ 。上面的运算是基于用系数来表示多项式的，事实上，由于 $n+1$ 个点可以唯一确定一个 $n$ 次多项式，我们可以改用 $n+1$ 个点来描述我们的多项式。并且由于我们并不关心形式幂级数的 $x$ 的取值，我们可以任意选取实数甚至虚数作为 $x$ 的值。这样做的好处是什么呢？我们发现，两个点值表达式相乘只需要将对应点的值相乘即可，也就是说，两个点值表达式做乘法运算是 $\Theta(n)$ 的！如果我们可以快速地将系数表达式转化成点值表达式，并快速地将点值表达式转化回来，就可以快速地完成多项式乘法。那么具体如何来做呢？我们先介绍一类神奇的数——单位根 $\omega$ 。单位根$n$ 次单位根是 $n$ 次幂为 $1$ 的复数。也即， $n$ 次单位根 $\omega_n$ 满足 $\omega_n^n=1$ 。由欧拉公式有 $\omega_n^k=\cos(k\times\frac{2\pi}{n})+i\sin(k\times\frac{2\pi}{n})$ 。在后文中，我们假设 $n$ 为 $2$ 的正整数次幂：于是单位根有这几个性质$\omega_n^{k+\frac n2}=-\omega_n^k$$\omega_{2n}^{2k}=\omega_n^k$$\omega_n^0=\omega_n^n=1$我们来简单证明一下这几个性质：$\omega_n^{k+\frac n2}=-\omega_n^k$\begin{align*} \omega_n^{k+\frac n2}&=\cos((k+\frac n2)\frac{2\pi}{n})+i\sin((k+\frac n2)\frac{2\pi}{n}) \\ &=\cos(k\times\frac{2\pi}{n}+\pi)+i\sin(k\times\frac{2\pi}{n}+\pi) \\ &=-(\cos(k\times\frac{2\pi}{n})+i\sin(k\times\frac{2\pi}{n})) \\ &=-\omega_n^k \end{align*}$\omega_{2n}^{2k}=\omega_n^k$\begin{align*} \omega_{2n}^{2k}&=\cos(2k\times\frac{2\pi}{2n})+i\sin(2k\times\frac{2\pi}{2n}) \\ &=\cos(k\times\frac{2\pi}{n})+i\sin(k\times\frac{2\pi}{n}) \\ &=\omega_n^k \end{align*}有了这两个性质，我们就能使用膜法了！快速傅里叶变换我们考虑将 $\omega_n$ 的 $0\sim n-1$ 次幂作为 $x$ 代入多项式 $F(x)$ 并求出点值。也即求出原多项式的离散傅里叶变换（DFT）我们先将 $F(x)$ 的各项按次数奇偶性分类：\begin{align*} F(x)&=\sum_{i=0}^{n-1}{f_ix^i} \\ &=\sum_{i=0}^{\frac n2-1}{f_{2i}x^{2i}}+\sum_{i=0}^{\frac n2-1}{f_{2i+1}x^{2i+1}} \\ \end{align*}令 $F_1(x)=\sum_{i=0}^{\frac n2-1}{f_{2i}x^{2i}}$ ， $F_2(x)=\sum_{i=0}^{\frac n2-1}{f_{2i+1}x^{2i+1}}$ ，则有 $F(x)=F_1(x^2)+xF_2(x^2)$ 。将 $\omega_n^k$ 代入 $x$ ：F(\omega_n^k)=F_1(\omega_n^{2k})+\omega_n^kF_2(\omega_n^{2k})再将 $\omega_n^{k+\frac n2}$ 代入 $x$ ：\begin{align*} F(\omega_n^{k+\frac n2})&=F_1(\omega_n^{2k+n})+\omega_n^{k+\frac n2}F_2(\omega_n^{2k+n}) \\ &=F_1(\omega_n^{2k}\times\omega_n^n)+(\omega_n^k\times\omega_{2n}^n)F_2(\omega_n^{2k}\times\omega_n^n) \\ &=F_1(\omega_n^{2k})-\omega_n^kF_2(\omega_n^{2k}) \end{align*}发现了吗？这是膜法！这两个式子间只有第二部分的符号有区别，也就是说，我们计算第一个式子的同时可以直接得到第二个式子的值！将这种奇偶分类求一半的操作递归下去，我们就得到了一个可以在 $\Theta(n\log n)$ 的时间复杂度内将多项式从系数表达式转化为以单位根各次幂为自变量的点值表达式的算法。快速傅里叶逆变换接下来我们再来考虑将这样的点值表达式转化回系数表达式的方法。也即离散傅里叶逆变换（IDFT）我们令 $\{y_0,y_1,y_2,\cdots,y_{n-1}\}$ 为 $\{f_0,f_1,f_2,\cdots,f_{n-1}\}$ 的离散傅里叶变换假设存在 $\{c_0,c_1,c_1,\cdots,c_{n-1}\}$ 满足 $c_k=\sum_{i=0}^{n-1}{y_i(\omega_n^{-k})^i}$也即 $Y(x)$ 在 $\omega_n^{-k}$ 处的点值，则有：\begin{align*} c_k&=\sum_{i=0}^{n-1}{y_i(\omega_n^{-k})^i} \\ &=\sum_{i=0}^{n-1}{(\sum_{j=0}^{n-1}{f_j(\omega_n^i)^j})(\omega_n^{-k})^i} \\ &=\sum_{i=0}^{n-1}{\sum_{j=0}^{n-1}{f_j(\omega_n^j)^i}(\omega_n^{-k})^i} \\ &=\sum_{i=0}^{n-1}{\sum_{j=0}^{n-1}{f_j(\omega_{n}^{j-k})^i}} \\ &=\sum_{j=0}^{n-1}{f_j\sum_{i=0}^{n-1}{(\omega_n^{j-k})^i}} \end{align*}令 $S(x)=\sum_{i=0}^{n-1}{x^i}$ ，将 $\omega_n^k(k\ne0)$ 代入：\because \begin{cases}\begin{align*} S(\omega_n^k)&=\sum_{i=0}^{n-1}{(\omega_n^k)^i} \\ \omega_n^kS(\omega_n^k)&=\sum_{i=1}^{n}{(\omega_n^k)^i} \\ \end{align*}\end{cases} \Rightarrow\omega_n^kS(\omega_n^k)-S(\omega_n^k)=(\omega_n^k)^n-1 \\ \therefore S(\omega_n^k)=\frac{(\omega_n^k)^n-1}{\omega_n^k-1}=0而当 $k=0$ 时显然 $S(\omega_n^0)=n$ 。接着来看之前的式子：c_k=\sum_{j=0}^{n-1}{f_j\sum_{i=0}^{n-1}{(\omega_n^{j-k})^i}}式子里面的 $\Sigma$ 当 $j\ne k$ 时值为 $0$ ，而 $j=k$ 时值为 $n$ 。因此有 $c_k=nf_k\Rightarrow f_k=\frac{c_k}{n}$于是只要对原多项式的离散傅里叶变换，以 $\omega_n^{-k}$ 为单位根做一次快速傅里叶变换，再将结果除以 $n$ 即可转化回原多项式。代码实现根据上面的理论可以很容易地写出快速傅里叶变换（FFT）的递归实现，但是一般使用时由于递归实现的常数过大，我们一般使用的是迭代实现的快速傅里叶变换。【例题】[Luogu3803] 多项式乘法 评测记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cmath&gt;#define N 2100010const double pi(acos(-1));struct comp &#123; double re,im; inline comp operator+(const comp&amp;x)const&#123; return(comp)&#123;re+x.re,im+x.im&#125;; &#125; inline comp operator-(const comp&amp;x)const&#123; return(comp)&#123;re-x.re,im-x.im&#125;; &#125; inline comp operator*(const comp&amp;x)const&#123; return(comp)&#123;re*x.re-im*x.im,re*x.im+im*x.re&#125;; &#125;&#125;a[N],b[N];inline void swap(comp&amp;a,comp&amp;b) &#123; comp tmp=a; a=b,b=tmp;&#125;int lmt,l,r[N];inline void getRev(int n) &#123; lmt=1,l=0; while(lmt&lt;=n) lmt&lt;&lt;=1,++l; for(int i=1;i&lt;lmt;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));&#125;inline void DFT(comp*a) &#123; comp wt,w,x,y; for(int i=0;i&lt;lmt;++i) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int i=1;i&lt;lmt;i&lt;&lt;=1) &#123; wt=(comp)&#123;cos(pi/i),sin(pi/i)&#125;; for(int j=0,step=i&lt;&lt;1;j&lt;lmt;j+=step) &#123; w=(comp)&#123;1,0&#125;; for(int k=0;k&lt;i;++k,w=w*wt) &#123; x=a[j+k],y=w*a[i+j+k]; a[j+k]=x+y,a[i+j+k]=x-y; &#125; &#125; &#125;&#125;inline void IDFT(comp*a) &#123; comp wt,w,x,y; for(int i=0;i&lt;lmt;++i) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int i=1;i&lt;lmt;i&lt;&lt;=1) &#123; wt=(comp)&#123;cos(pi/i),-sin(pi/i)&#125;; for(int j=0,step=i&lt;&lt;1;j&lt;lmt;j+=step) &#123; w=(comp)&#123;1,0&#125;; for(int k=0;k&lt;i;++k,w=w*wt) &#123; x=a[j+k],y=w*a[i+j+k]; a[j+k]=x+y,a[i+j+k]=x-y; &#125; &#125; &#125; for(int i=0;i&lt;lmt;++i) a[i].re/=lmt,a[i].im/=lmt;&#125;int n,m;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;++i) scanf("%lf",&amp;a[i].re); for(int i=0;i&lt;=m;++i) scanf("%lf",&amp;b[i].re); getRev(n+m+2); DFT(a); DFT(b); for(int i=0;i&lt;lmt;++i) a[i]=a[i]*b[i]; IDFT(a); for(int i=0;i&lt;=n+m;++i) printf("%.0lf ",a[i].re+0.1); return 0;&#125;优化三次变两次MTT暂咕快速数论变换如果是在模意义下做运算，我们还有一种算法可以胜任，那就是快速数论变换（NTT）考虑到做快速傅里叶变换时我们将单位根代入求出点值，如果模意义下有与单位根性质类似的数，是否可以代替单位根完成一样的工作呢？答案是肯定的，这一类数是——原根 $g$ 。原根我们先给出阶的定义：若 $a\perp p$ 且 $p&gt;1$ ， $a$ 模 $p$ 的阶为满足 $a^n\equiv1\pmod{p}$ 的最小的 $n$ ，记为 $\delta_p(a)$ 。若 $p$ 为正整数， $a$ 是整数，且 $\delta_p(a)=\varphi(p)$ ，则 $a$ 为模 $p$ 的一个原根。（ $\varphi(n)$ 为小于等于 $n$ 的数中与 $n$ 互质的数的个数）原根有一些很有意思的性质：若模 $p$ 存在原根，则其一定有 $\varphi(\varphi(p))$ 个原根。若 $p$ 为质数， $g$ 为 $p$ 的一个原根，则 $g^i\pmod{p}$ 对于不同的 $i\in[1,p)$ 值都不同同时原根在模意义下与单位根有相同的性质，因此我们可以使用原根代替单位根在模意义下做快速数论变换。代码实现类似快速傅里叶变换，只把里面的单位根相应地换成原根，并注意取模即可。【例题】[Luogu3803] 多项式乘法 评测记录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#define MOD 998244353#define N 2100010typedef long long i64;inline void swap(int&amp;a,int&amp;b) &#123; int tmp(a); a=b,b=tmp;&#125;inline int pow(int a,int b) &#123; int ans(1); while(b) &#123; ans=b&amp;1?(i64)ans*a%MOD:ans; a=(i64)a*a%MOD; b&gt;&gt;=1; &#125; return ans;&#125;int lmt,l,r[N];inline void getRev(int n) &#123; lmt=1,l=0; while(lmt&lt;=n) lmt&lt;&lt;=1,++l; for(int i=1;i&lt;lmt;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));&#125;inline void DFT(int*a) &#123; int wt,w,x,y; for(int i=0;i&lt;lmt;++i) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int i=1;i&lt;lmt;i&lt;&lt;=1) &#123; wt=pow(3,(MOD-1)/(i&lt;&lt;1)); for(int j=0,step=i&lt;&lt;1;j&lt;lmt;j+=step) &#123; w=1; for(int k=0;k&lt;i;++k,w=(i64)w*wt%MOD) &#123; x=a[j+k],y=(i64)w*a[i+j+k]%MOD; a[j+k]=(x+y)%MOD,a[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125;&#125;inline void IDFT(int*a) &#123; int wt,w,x,y; for(int i=0;i&lt;lmt;++i) if(i&lt;r[i]) swap(a[i],a[r[i]]); for(int i=1;i&lt;lmt;i&lt;&lt;=1) &#123; wt=pow(332748118,(MOD-1)/(i&lt;&lt;1)); for(int j=0,step=i&lt;&lt;1;j&lt;lmt;j+=step) &#123; w=1; for(int k=0;k&lt;i;++k,w=(i64)w*wt%MOD) &#123; x=a[j+k],y=(i64)w*a[i+j+k]%MOD; a[j+k]=(x+y)%MOD,a[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125; int bk(pow(lmt,MOD-2)); for(int i=0;i&lt;lmt;++i) a[i]=(i64)a[i]*bk%MOD;&#125;int n,m,a[N],b[N];int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;++i) scanf("%d",a+i); for(int i=0;i&lt;=m;++i) scanf("%d",b+i); getRev(n+m+2); DFT(a); DFT(b); for(int i=0;i&lt;lmt;++i) a[i]=(i64)a[i]*b[i]%MOD; IDFT(a); for(int i=0;i&lt;=n+m;++i) printf("%d ",a[i]); return 0;&#125;预处理原根我们来考虑一个优化：在 $\text{NTT}$ 的过程中我们多次使用了原根的各次幂，如果我们能将原根的各次幂预处理出来，而不是每次使用都计算一遍，就能有很大的常数优化！在多项式乘法中我们只做了 $3$ 次 $\text{NTT}$ ，所以看上去常数优化并不明显。但是在后面的内容中，随着 $\text{NTT}$ 次数的增多，预处理原根的优化效果将愈发明显。【例题】[Luogu3803] 多项式乘法 评测记录：$1.83s\rightarrow1.3s$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;using std::reverse;#define MOD 998244353#define N 2100010typedef long long i64;typedef unsigned long long u64;inline int pow(int a,int b) &#123; int ans(1); while(b) &#123; ans=b&amp;1?(i64)ans*a%MOD:ans; a=(i64)a*a%MOD; b&gt;&gt;=1; &#125; return ans;&#125;int lmt(1),r[N],w[N];inline int getLen(int n) &#123; return 1&lt;&lt;(32-__builtin_clz(n));&#125;inline void init(int n) &#123; int l(0); while(lmt&lt;=n) lmt&lt;&lt;=1,++l; for(int i=1;i&lt;lmt;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); int wn(pow(3,(MOD-1)&gt;&gt;l)); w[lmt&gt;&gt;1]=1; for(int i=(lmt&gt;&gt;1)+1;i&lt;lmt;++i) w[i]=(i64)w[i-1]*wn%MOD; for(int i=(lmt&gt;&gt;1)-1;i;--i) w[i]=w[i&lt;&lt;1]; lmt=l;&#125;inline void DFT(int*a,int l) &#123; static u64 tmp[N]; int u(lmt-__builtin_ctz(l)),t; for(int i=0;i&lt;l;++i) tmp[r[i]&gt;&gt;u]=a[i]; for(int i=1;i&lt;l;i&lt;&lt;=1) for(int j=0,step=i&lt;&lt;1;j&lt;l;j+=step) for(int k=0;k&lt;i;++k) &#123; t=tmp[i+j+k]*w[i+k]%MOD; tmp[i+j+k]=tmp[j+k]+MOD-t; tmp[j+k]+=t; &#125; for(int i=0;i&lt;l;++i) a[i]=tmp[i]%MOD;&#125;inline void IDFT(int*a,int l) &#123; reverse(a+1,a+l); DFT(a,l); int bk(MOD-(MOD-1)/l); for(int i=0;i&lt;l;++i) a[i]=(i64)a[i]*bk%MOD;&#125;int n,m,a[N],b[N],l;int main() &#123; scanf("%d%d",&amp;n,&amp;m); init(n+m+2); for(int i=0;i&lt;=n;++i) scanf("%d",a+i); for(int i=0;i&lt;=m;++i) scanf("%d",b+i); l=getLen(n+m+2); DFT(a,l); DFT(b,l); for(int i=0;i&lt;l;++i) a[i]=(i64)a[i]*b[i]%MOD; IDFT(a,l); for(int i=0;i&lt;=n+m;++i) printf("%d ",a[i]); return 0;&#125;多项式求逆我们已经知道，当 $f_0\ne0$ 时 $F(x)$ 存在唯一乘法逆元。接下来我们就探讨一下如何求得一个多项式的乘法逆元。]]></content>
      <tags>
        <tag>资料</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu5373]多项式复合函数]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu5373-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[此处题面前言这是这道题复杂度比较正确的一个常数奇大无比的算法，源自 $\text{R.P.BRENT}$ 和 $\text{H.T.KUNG}$ 在 $1978$ 年发表的论文（也就是题面里说的那个全嘤文pdf），我在 $\text{5月15日}$ 蒯到手之后肝了一个晚上，在神犇 rqy 的帮助下成功地写出了66分点名被卡做法awsl，后来研究别人代码的时候发现了 预处理原根 这种神奇操作，于是总算成功AC。正文这种做法基于对外层函数的泰勒展开，我们把内层函数 $G$ 的前 $m$ 项拆出来，记作 $G_m$ ，把剩下的记作 $G_r$ 。(这个 $m$ 到底取多少我们分析复杂度的时候再确定)然后进行泰勒展开：F(G)=F(G_m+G_r)=F(G_m)+F'(G_m)G_r+\frac12F''(G_m)G_r^2+\cdots由于我们只需要求 $F(G)$ 前 $n+1$ 项的值，所以我们只需要知道这个展开式前 $\lceil\frac nm\rceil$ 项的值即可，即：令 $l=\lceil\frac nm\rceil$ ，有F(G(x))\equiv F(G_m(x))+F'(G_m(x))G_r(x)+\cdots+\frac1{l!}F^{(l)}(G_m(x))G_r^l(x)\pmod{x^{n+1}}因此我们只要计算出 $F(G_m(x))$ 的各阶导和 $G_r(x)$ 的各次幂，就可以累加得到 $F(G(x))$ 了。$G_r(x)$ 只需要从 $G(x)$ 中截出来即可，那么如何计算 $F(G_m(x))$ 呢？考虑外层函数最高次项次数为 $2$ 的幂的情况，即：令 $F(x)=f_0+\cdots+f_jx^j$ 且 $j$ 为 $2$ 的正整数次幂，有F(G)=F_1(G)+G^{\frac j2}\cdot F_2(G)这里 $F_1$ 和 $F_2$ 都是最高次项次数为 $\frac j2$ 的多项式，这样一来我们就能递归地计算 $F(G_m(x))$ 了。考虑这一步的时间复杂度：我们令 $M(n)$ 为完成两个 $n$ 次多项式的乘法的时间，即： $M(n)=O(n\log n)$我们设 $T(j)$ 为计算 $G^{\frac j2}$ 和 $F(G)$ 的时间，则有T(j)\leqslant2T(\frac j2)+O(M(\min(jm,n)))我们令 $r$ 为满足 $n\cdot2^k\leqslant jm$ 的最大的 $k$ ，则有T(j)=O(M(n)+2M(n)+\cdots+2^rM(n))+2^{r+1}T(\frac{j}{2^{r+1}})T(j)\leqslant O(\frac{jmM(n)}{n})+(\frac{2jm}{n})T(\frac{j}{2^{r+1}})又因为 $n\cdot2^{r+1}&gt;jm$ ，有T(\frac{j}{2^{r+1}})=O(M(\frac{jm}{2^{r+1}})+2M(\frac{jm}{2^{r+2}})+\cdots)=O(M(n)+2M(\lceil\frac n2\rceil)+4M(\lceil\frac n4\rceil)+\cdots)=O(\log nM(n))因此，我们有 $T(j)=O(\frac{jm\log n}{n}M(n))$ ，所以求解 $F(G_m(x))$ 的时间复杂度为 $O(mn\log^2n)$ 。我们再来考虑对 $F(G_m(x))$ 求导：令 $H(x)=F(G(x))$根据复合函数求导法则，我们有 $H’(x)=F’(G(x))\cdot G’(x)$ ，因此 $F’(G_m(x))=H’(x)\cdot(G_m’(x))^{-1}$ ，由此我们可以计算出泰勒展开式中某一项之后与之前的结果累加得到 $H(x)$ ，同时计算出下一项中 $F(G_m(x))$ 的对应阶导。每计算一次导数的时间复杂度是 $O(n\log n)$ 的，因此计算出所有项的时间复杂度是 $O(l\cdot n\log n)=O(\frac{n^2\log n}{m})$ 。我们已经得到了 $F(G_m(x))$ 的各阶导，而 $G_r(x)$ 的各次幂只需要挨个乘起来即可，时间复杂度也是 $O(\frac{n^2\log n}{m})$ 的。之后各项的计算和累加同样是 $O(\frac{n^2\log n}{m})$ 的，因此这个算法的总复杂度为 $O(mn\log^2n+\frac{n^2\log n}{m})$ 。我们考虑 $m$ 的取值：根据均值不等式，当 $mn\log^2n\sim\frac{n^2\log n}{m}$ 时时间复杂度最优，因此解得当 $m\sim\sqrt{\frac{n}{\log n}}$ 时有最优时间复杂度 $O((n\log n)^{1.5})$ 。最后还是附上参考代码比较好，这个东西由于常数原因必须 预处理原根 才能卡过去，而且好像也没有什么实际用处。。就当是练习码力了 2333123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#pragma GCC optimize("Ofast,inline")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native")#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define MOD 998244353#define G 332748118#define N 262210#define re register#define gc pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++typedef long long ll;static char buf[100000],*pa(buf),*pb(buf);static char pbuf[3000000],*pp(pbuf),st[15];inline int read() &#123; re int x(0);re char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48,c=gc; return x;&#125;inline void write(re int v) &#123; if(v==0) *pp++=48; else &#123; re int tp(0); while(v) st[++tp]=v%10+48,v/=10; while(tp) *pp++=st[tp--]; &#125; *pp++=32;&#125;inline int pow(re int a,re int b) &#123; re int ans(1); while(b) ans=b&amp;1?(ll)ans*a%MOD:ans,a=(ll)a*a%MOD,b&gt;&gt;=1; return ans;&#125;int inv[N],ifac[N];inline void pre(re int n) &#123; inv[1]=ifac[0]=1; for(re int i(2);i&lt;=n;++i) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD; for(re int i(1);i&lt;=n;++i) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;&#125;inline int getLen(re int t) &#123; return 1&lt;&lt;(32-__builtin_clz(t));&#125;int lmt(1),r[N],w[N];inline void init(re int n) &#123; re int l(0); while(lmt&lt;=n) lmt&lt;&lt;=1,++l; for(re int i(1);i&lt;lmt;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); re int wn(pow(3,(MOD-1)/lmt)); w[lmt&gt;&gt;1]=1; for(re int i((lmt&gt;&gt;1)+1);i&lt;lmt;++i) w[i]=(ll)w[i-1]*wn%MOD; for(re int i((lmt&gt;&gt;1)-1);i;--i) w[i]=w[i&lt;&lt;1];&#125;inline void DFT(int*a,re int l) &#123; static unsigned long long tmp[N]; re int u(__builtin_ctz(lmt)-__builtin_ctz(l)),t; for(re int i(0);i&lt;l;++i) tmp[i]=(a[r[i]&gt;&gt;u])%MOD; for(re int i(1);i&lt;l;i&lt;&lt;=1) for(re int j(0),step(i&lt;&lt;1);j&lt;l;j+=step) for(re int k(0);k&lt;i;++k) t=(ll)w[i+k]*tmp[i+j+k]%MOD, tmp[i+j+k]=tmp[j+k]+MOD-t, tmp[j+k]+=t; for(re int i(0);i&lt;l;++i) a[i]=tmp[i]%MOD;&#125;inline void IDFT(int*a,re int l) &#123; std::reverse(a+1,a+l);DFT(a,l); re int bk(MOD-(MOD-1)/l); for(re int i(0);i&lt;l;++i) a[i]=(ll)a[i]*bk%MOD;&#125;int n,m;int a[N],b[N],c[N];void getInv(int*a,int*b,int deg) &#123; if(deg==1) b[0]=pow(a[0],MOD-2); else &#123; static int tmp[N]; getInv(a,b,(deg+1)&gt;&gt;1); re int l(getLen(deg&lt;&lt;1)); for(re int i(0);i&lt;l;++i) tmp[i]=i&lt;deg?a[i]:0; DFT(tmp,l),DFT(b,l); for(re int i(0);i&lt;l;++i) b[i]=(2ll-(ll)tmp[i]*b[i]%MOD+MOD)%MOD*b[i]%MOD; IDFT(b,l); for(re int i(deg);i&lt;l;++i) b[i]=0; &#125;&#125;inline void getDer(int*a,int*b,int deg) &#123; for(re int i(0);i+1&lt;deg;++i) b[i]=(ll)a[i+1]*(i+1)%MOD; b[deg-1]=0;&#125;void getComp(int*a,int*b,int k,int m,int&amp;n,int*c,int*d) &#123; if(k==1) &#123; for(re int i(0);i&lt;m;++i) c[i]=0,d[i]=b[i]; n=m,c[0]=a[0]; &#125; else &#123; static int t1[N],t2[N]; int nl(n),nr(n),*cl,*cr,*dl,*dr; getComp(a,b,k&gt;&gt;1,m,nl,cl=c,dl=d); getComp(a+(k&gt;&gt;1),b,(k+1)&gt;&gt;1,m,nr,cr=c+nl,dr=d+nl); n=std::min(n,nl+nr-1); re int _l(getLen(nl+nr)); for(re int i(0);i&lt;_l;++i) t1[i]=i&lt;nl?dl[i]:0; for(re int i(0);i&lt;_l;++i) t2[i]=i&lt;nr?cr[i]:0; DFT(t1,_l),DFT(t2,_l); for(re int i(0);i&lt;_l;++i) t2[i]=(ll)t1[i]*t2[i]%MOD; IDFT(t2,_l); for(re int i(0);i&lt;n;++i) c[i]=((i&lt;nl?cl[i]:0)+t2[i])%MOD; for(re int i(0);i&lt;_l;++i) t2[i]=i&lt;nr?dr[i]:0; DFT(t2,_l); for(re int i(0);i&lt;_l;++i) t2[i]=(ll)t1[i]*t2[i]%MOD; IDFT(t2,_l); for(re int i(0);i&lt;n;++i) d[i]=t2[i]; &#125;&#125;inline void getComp(int*a,int*b,int*c,int deg) &#123; static int ts[N],ps[N],c0[N],_t1[N],idM[N]; int M(std::max((int)ceil(sqrt(deg/log2(deg))*2.5),2)),_n(deg+deg/M); getComp(a,b,deg,M,_n,c0,_t1); re int _l(getLen(_n+deg)); for(re int i(_n);i&lt;_l;++i) c0[i]=0; for(re int i(0);i&lt;_l;++i) ps[i]=i==0; for(re int i(0);i&lt;_l;++i) ts[i]=M&lt;=i&amp;&amp;i&lt;deg?b[i]:0; getDer(b,_t1,M); for(re int i(M-1);i&lt;deg;++i) _t1[i]=0; /// Important!!! getInv(_t1,idM,deg); for(int i=deg;i&lt;_l;++i) idM[i]=0; DFT(ts,_l),DFT(idM,_l); for(re int t(0);t*M&lt;deg;++t) &#123; for(re int i(0);i&lt;_l;++i) _t1[i]=i&lt;deg?c0[i]:0; DFT(ps,_l),DFT(_t1,_l); for(re int i(0);i&lt;_l;++i) _t1[i]=(ll)_t1[i]*ps[i]%MOD, ps[i]=(ll)ps[i]*ts[i]%MOD; IDFT(ps,_l),IDFT(_t1,_l); for(re int i(deg);i&lt;_l;++i) ps[i]=0; for(re int i(0);i&lt;deg;++i) c[i]=((ll)_t1[i]*ifac[t]+c[i])%MOD; getDer(c0,c0,_n); for(re int i(_n-1);i&lt;_l;++i) c0[i]=0; DFT(c0,_l); for(re int i(0);i&lt;_l;++i) c0[i]=(ll)c0[i]*idM[i]%MOD; IDFT(c0,_l); for(re int i(_n-1);i&lt;_l;++i) c0[i]=0; &#125;&#125;int main() &#123; n=read(),m=read(); for(re int i(0);i&lt;=n;++i) a[i]=read(); for(re int i(0);i&lt;=m;++i) b[i]=read(); m=(n&gt;m?n:m)+1; pre(m);init(m*5); getComp(a,b,c,m); for(re int i(0);i&lt;=n;++i) write(c[i]); fwrite(pbuf,1,pp-pbuf,stdout); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu5431]乘法逆元2]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu5431-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%832%2F</url>
    <content type="text"><![CDATA[此处题面题外话其实我觉得这道题的考点是快读.jpg没有快读的后果正文\large\text{以下运算均在模 }p\text{ 意义下进行}\large\sum_{i=1}^{n}{\frac{k^i}{a_i}}=\sum_{i=1}^{n}{k^i\cdot a_i^{-1}}我们考虑先求出 $a$ 序列的前缀积，记为 $s$ ：\large s_i=\prod_{j=1}^{i}{a_j}记 $a$ 序列前缀积的逆元为 $t$ ，此时如果我们知道这个序列，我们就可以知道 $a$ 中任意一个数的逆元：\large a_i^{-1}=s_{i-1}\cdot t_i而 前缀积的逆元 就等于 逆元的前缀积 ，所以我们只要求出 $t_n$ 就可以线性递推出整个 $t$ 序列了：\large t_n=s_n^{p-2}\large t_i=a_{i+1}\cdot t_{i+1}这样我们就求得了 $a$ 序列的逆元，再用秦九韶算法就能在线性时间内算出题目的式子了。参考代码前方极差码风警告！123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#define N 5000010#define re register#define gc pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++typedef long long ll;static char buf[100000],*pa(buf),*pb(buf);inline int read() &#123; re int x(0);re char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48,c=gc; return x;&#125;inline int pow(int a,int b,int p) &#123; int ans(1); while(b) ans=b&amp;1?(ll)ans*a%p:ans,a=(ll)a*a%p,b&gt;&gt;=1; return ans;&#125;int n,p,k,a[N],s[N]=&#123;1&#125;,inv_s[N],ans;int main() &#123; n=read(),p=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(),s[i]=(ll)s[i-1]*a[i]%p; inv_s[n]=pow(s[n],p-2,p); for(int i=n-1;i;--i) inv_s[i]=(ll)inv_s[i+1]*a[i+1]%p; for(int i=n;i;--i) ans=((ll)inv_s[i]*s[i-1]%p+ans)*k%p; printf("%d",ans); return 0;&#125;5e6 的输入，千万记得快读！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu4315]月下“毛景树”]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu4315-%E6%9C%88%E4%B8%8B%E2%80%9C%E6%AF%9B%E6%99%AF%E6%A0%91%E2%80%9D%2F</url>
    <content type="text"><![CDATA[此处题面前言这道题其实就是把 单点修改 、 区间染色 、 区间加 以及 区间最大值 这四种基本的序列操作出到了树上，很明显是用 树链剖分 + 线段树 解决，但是因为我太蒻了，树剖码到一半码不下去了，所以就全删了改码了个 Link/Cut Tree ，顺便 拿了这个题的RANK1 。边转点树剖的边转点大家都知道是把每条边的权值给深度较深的那个点，但是我们不能在 LCT 上也这么做，因为有 makeroot 操作的存在， LCT 上结点的父子关系不是确定的，所以我们采取建立 虚拟结点 的方式：1234// 第 i 条边连接 u 和 v 这两个点，权值为 wval[n+i]=maxv[n+i]=w;link(u,n+i);link(n+i,v);用 $n$ + $i$ 号结点表示第 $i$ 条边，再用它去分别连接原先的边连接的结点。需要注意的地方这种写法会产生 $2n$ 个结点， 空间千万要开够！标记上传下传的时候要分 原结点 和 虚拟结点 两种情况讨论！标记这道题我们只需要维护一个 区间染色 的标记和一个 区间加 的标记就行，我多维护了一个 siz 数组储存子树内 虚拟结点 的数量，上传时判断当前结点是不是 虚拟结点 就行。标记下传的时候要 先下传区间染色，再下传区间加 ，若是先下传了 区间加 ，后面 区间染色 的时候就会 覆盖掉最后附上此题 $AC$ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#define N 200010#define lc(x) ch[x][0]#define rc(x) ch[x][1]#define re register#define gc pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++inline int max(int a,int b)&#123;return b&lt;a?a:b;&#125;inline void swap(int&amp;a,int&amp;b)&#123;int tmp(a);a=b,b=tmp;&#125;static char buf[100000],*pa(buf),*pb(buf);static char pbuf[3000000],*pp(pbuf),st[15];inline char gtc() &#123; re char c(gc); while(c!='S'&amp;&amp;c!='h'&amp;&amp;c!='o'&amp;&amp;c!='d'&amp;&amp;c!='a') c=gc; return c;&#125;inline int read() &#123; re int x(0);re char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48,c=gc; return x;&#125;inline void write(re int v) &#123; if(!v) *pp++=48; else &#123; re char*tp(st); while(v) *++tp=v%10+48,v/=10; while(tp!=st) *pp++=*tp--; &#125; *pp++='\n';&#125;int n,u,v,w;char opt;int ch[N][2],fa[N],rev[N],val[N],maxv[N],ass[N],addv[N],siz[N];inline void assign(int x,int y)&#123;val[x]=x&gt;n?y:0,maxv[x]=siz[x]&gt;0?y:0,addv[x]=0,ass[x]=y;&#125;inline void add(int x,int y)&#123;val[x]+=x&gt;n?y:0,maxv[x]+=siz[x]&gt;0?y:0,addv[x]+=siz[x]&gt;0?y:0;&#125;inline void up(int x)&#123;siz[x]=siz[lc(x)]+siz[rc(x)]+(x&gt;n),maxv[x]=max(val[x],max(maxv[lc(x)],maxv[rc(x)]));&#125;inline void down(int x) &#123; if(rev[x]) rev[lc(x)]^=1,rev[rc(x)]^=1,rev[x]=0,swap(lc(x),rc(x)); if(ass[x]) assign(lc(x),ass[x]),assign(rc(x),ass[x]),ass[x]=0; if(addv[x]) add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;&#125;inline int nrt(int x)&#123;return x==lc(fa[x])||x==rc(fa[x]);&#125;void psa(int x)&#123;if(nrt(x))psa(fa[x]);down(x);&#125;inline void rotate(int x) &#123; int y(fa[x]),z(fa[y]),k(x==rc(y)); ch[y][k]=ch[x][k^1],ch[x][k^1]=y;if(nrt(y))ch[z][y==rc(z)]=x; if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z,up(y);&#125;inline void splay(int x) &#123; int y,z; for(psa(x);nrt(x);rotate(x)) &#123;y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);&#125;up(x);&#125;inline void access(int x)&#123;for(int y(0);x;x=fa[y=x])splay(x),rc(x)=y,up(x);&#125;inline void mrt(int x)&#123;access(x),splay(x),rev[x]^=1;&#125;inline void split(int x,int y)&#123;mrt(x),access(y),splay(y);&#125;inline void link(int x,int y)&#123;mrt(x),fa[x]=y;&#125;int main() &#123; n=read(); for(re int i(1);i&lt;n;++i) siz[n+i]=1; for(re int i(1);i&lt;n;++i) u=read(),v=read(),val[n+i]=maxv[n+i]=read(),link(u,n+i),link(n+i,v); opt=gtc(); while(opt!='S') &#123; u=read(),v=read(); switch(opt) &#123; case'h': access(n+u),splay(n+u),val[n+u]=v; break; case'o': split(u,v),assign(v,read()); break; case'd': split(u,v),add(v,read()); break; case'a': split(u,v),write(maxv[v]); &#125; opt=gtc(); &#125; fwrite(pbuf,1,pp-pbuf,stdout); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Link/Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】学习资料]]></title>
    <url>%2F%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[收集的一些资料，留给自己慢慢啃。各路OJ洛谷、bzoj、POJ、UOJ、LibreOJ、51Nod、OIH、评测鸭、hihoCoder、OHO-OJ、Vijos、ZHZXOJ、ZOJ博文索引yzhang、bztMinamoto、自为风月马前卒、JasonZhan、huyufeifei、xehoth、饕餮传奇、Venus、yyb、rqy、Mrsrz、xht37、Victor、fcwww、EI、诗乃、Siyuan、zzq、zkw数据结构猫树、zkw线段树、Leafy Tree、Link-Cut Tree、树套树、后缀数组、回文自动机算法分治、动态dp、生成函数其它OI Wiki、算法可视化、SAM可视化、题号查找器、图可视化、OEIS、MaHua在线Markdown编辑器、矩阵乘法、图床搭建、MiNa]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu3372]线段树1]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu3372-%E7%BA%BF%E6%AE%B5%E6%A0%911%2F</url>
    <content type="text"><![CDATA[此处题面去了 WC2019 的同学应该对 指令集 有些印象，没去的同学 ( 比如我 ) 可能也通过一些途径了解到了这个暴力踩标程的毒瘤 ( 据说现场踩 Ynoi五彩斑斓的世界 ) 。但是由于我太弱，实在过不了那道题 dllxl Orz ，所以我就来拿这道题练手了。一、指令集是什么？其实就是压位，常用的是压256位。也有能压512位的，但大部分情况不支持 ( 硬件 + 软件 ) 。二、它为什么快？就像压位高精会比裸高精快， bitset 比 bool数组 快一样，你把8个32位的 int 压成一个256位的玩意儿，每次操作可以看成是同时对8个 int 进行操作 ( 但其实并不是这样 ) ，所以理论上常数会是原来的 $\frac{1}{8}$ ( 但其实做不到 $\frac{1}{8}$ ) 。三、它要怎么用？请自行摸索首先你需要 immintrin.h 库，里面啥都有然后再在程序前加上 #pragma GCC target(&quot;avx,avx2&quot;) ，这样你就可以把你的 int 啊 long long 啊什么的压成 __m256i ，把 float 压成 __m256 ，还能把 double 压成 __m256d 。什么你问我具体怎么做？我不知道啊.jpg这里是连快读都没用的$O\left(n^2\right)$暴力评测记录。最后附上这道题的程序，想学学指令集的可以看看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#pragma GCC optimize("Ofast,fast-math")#pragma GCC target("avx,avx2")#include &lt;cstdio&gt;#include &lt;immintrin.h&gt;int n,m,num,x[5],opt,p,q,k;__m256i a[25010];inline void add(int l,int r,int v) &#123; while(((l-1)&amp;3)&amp;&amp;l&lt;=r)((long long*)(a+(l&gt;&gt;2)+1))[(l&amp;3)-1]+=v,++l; if(l==r+1)return; while((r&amp;3)&amp;&amp;l&lt;=r)((long long*)(a+(r&gt;&gt;2)+1))[(r&amp;3)-1]+=v,--r; if(l==r+1)return; l=(l&gt;&gt;2)+1,r&gt;&gt;=2; __m256i s=_mm256_set_epi64x(v,v,v,v); while(l&lt;=r)a[l]=_mm256_add_epi64(a[l],s),++l;&#125;inline long long query(int l,int r) &#123; long long ans(0); while(((l-1)&amp;3)&amp;&amp;l&lt;=r)ans+=((long long*)(a+(l&gt;&gt;2)+1))[(l&amp;3)-1],++l; if(l==r+1)return ans; while((r&amp;3)&amp;&amp;l&lt;=r)ans+=((long long*)(a+(r&gt;&gt;2)+1))[(r&amp;3)-1],--r; if(l==r+1)return ans; l=(l&gt;&gt;2)+1,r&gt;&gt;=2; __m256i s=_mm256_set_epi64x(0,0,0,0); while(l&lt;=r)s=_mm256_add_epi64(a[l],s),++l; for(int i=0;i&lt;4;++i) ans+=((long long*)&amp;s)[i]; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m);num=n&gt;&gt;2; for(int i=1;i&lt;=num;++i) &#123; for(int j=1;j&lt;=4;++j) scanf("%d",x+j); a[i]=_mm256_set_epi64x(x[4],x[3],x[2],x[1]); &#125; for(int i=1;i&lt;=(n&amp;3);++i) scanf("%d",x+i); a[++num]=_mm256_set_epi64x(x[4],x[3],x[2],x[1]); while(m--) &#123; scanf("%d%d%d",&amp;opt,&amp;p,&amp;q); if(opt==1) scanf("%d",&amp;k),add(p,q,k); else printf("%lld\n",query(p,q)); &#125; return 0;&#125;这道题要开 long long ，如果是 int 的话程序第一句的 Ofast 优化去掉也能过！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[JLOI2014]松鼠的新家]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-JLOI2014-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[此处题面由于树上两点路径唯一，维尼的路线也是唯一的，因此我们只要 统计维尼经过每个点的次数 即可。而树上路径又跟 LCA 什么的有关，因此这道题的做法就多种多样了。由于只有一次询问，比较容易想到的做法是 树上差分 后求 LCA 轻松搞定。再想深一点你会发现这道题简直就是 树链剖分 的板子，再加上这道题不用维护什么子树信息，所以 树链剖分 能做 Link/Cut Tree 当然也能做！需要注意的几点：这道题 LCT 得卡常，写的时候注意不要太飘；由于两条链相交的点会被重复计算，因此每次加的时候链头链尾要有一个减 1 (我是链尾)；最后一个点是不需要准备糖果的！输出答案的时候记得把标记都下放了 (我是先 makeroot 再输出) 。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#define N 300010#define lc(x) ch[x][0]#define rc(x) ch[x][1]#define re registerinline void swap(re int&amp;a,re int&amp;b)&#123;re int tmp(a);a=b,b=tmp;&#125;int ch[N][2],fa[N],rev[N],val[N],addv[N];inline void add(re int x,re int y)&#123;val[x]+=y,addv[x]+=y;&#125;inline void down(re int x) &#123; if(rev[x]) rev[lc(x)]^=1,rev[rc(x)]^=1,swap(lc(x),rc(x)),rev[x]=0; if(addv[x]) add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;&#125;inline int nrt(re int x)&#123;return x==lc(fa[x])||x==rc(fa[x]);&#125;void psa(int x)&#123;if(nrt(x))psa(fa[x]);down(x);&#125;inline void rotate(re int x) &#123; re int y(fa[x]),z(fa[y]),k(x==rc(y)); ch[y][k]=ch[x][!k],ch[x][!k]=y;if(nrt(y))ch[z][y==rc(z)]=x; if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z;&#125;inline void splay(re int x) &#123; re int y,z; for(psa(x);nrt(x);rotate(x)) &#123;y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);&#125;&#125;inline void access(re int x)&#123;for(re int y(0);x;x=fa[y=x])splay(x),rc(x)=y;&#125;inline void mrt(re int x)&#123;access(x),splay(x),rev[x]^=1;&#125;inline void link(re int x,re int y)&#123;mrt(x),fa[x]=y;&#125;int n,a[N],x,y;int main() &#123; scanf("%d",&amp;n); for(re int i(1);i&lt;=n;++i) scanf("%d",a+i); for(re int i(1);i&lt;n;++i) scanf("%d%d",&amp;x,&amp;y),link(x,y); for(re int i(1);i&lt;n;++i) --val[a[i+1]],mrt(a[i]),access(a[i+1]),splay(a[i+1]),add(a[i+1],1); for(re int i(1);i&lt;=n;++i) mrt(i),printf("%d\n",val[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Link/Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[SDOI2011]染色]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-SDOI2011-%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[此处题面这道题的做法其实已经很明显了， 树链剖分 + 线段树 ，只是看到区间赋值心血来潮想用 珂朵莉树 水，结果就过了╮(╯▽╰)╭操作 1 就是 区间推平 ( assign ) ，操作 2 可以像找 最近公共祖先 ( LCA ) 一样一边往上方跳一边统计，由于珂朵莉树的结点存储的是一段值相同的连续区间，我们只需要记录上一次访问的结点的值与当前结点的值比较，若不同则更新并计数。值得注意的 $3$ 点：由于我们是统计链上的连续段，所以我们应从深度大的结点往小的枚举。由于我们是从链的两端分别往上跳，所以我们需要分别记录两边上次访问的结点的值。最后处于同一条链上时，需要考虑两端的值相同的情况。最后放上 $AC$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;set&gt;using std::set;#define N 100010struct node &#123; int l,r,v; node(int L,int R=-1,int V=0):l(L),r(R),v(V)&#123;&#125; inline int operator&lt;(const node&amp;x)const&#123;return l&lt;x.l;&#125;&#125;;set&lt;node&gt;s;typedef set&lt;node&gt;::iterator IT;inline IT split(int pos) &#123; IT it(--s.upper_bound(node(pos))); if(it-&gt;l==pos) return it; int L(it-&gt;l),R(it-&gt;r),V(it-&gt;v); s.erase(it),s.insert(node(L,pos-1,V)); return s.insert(node(pos,R,V)).first;&#125;inline void assign(int l,int r,int v) &#123; IT itr(split(r+1)),itl(split(l)); s.erase(itl,itr);s.insert(node(l,r,v));&#125;int n,m,a[N],x,y,z;char opt;int e,bg[N],nx[N&lt;&lt;1],to[N&lt;&lt;1];inline void link(int u,int v)&#123;to[++e]=v,nx[e]=bg[u],bg[u]=e;&#125;int fa[N],dep[N],siz[N],ws[N];void dfs1(int now,int f) &#123; fa[now]=f,dep[now]=dep[f]+1,siz[now]=1; int mx(-1); for(int i=bg[now];i;i=nx[i]) if(to[i]!=f) &#123; dfs1(to[i],now); siz[now]+=siz[to[i]]; if(siz[to[i]]&gt;mx) mx=siz[to[i]],ws[now]=to[i]; &#125;&#125;int cnt,top[N],id[N],wt[N];void dfs2(int now,int tp) &#123; top[now]=tp,id[now]=++cnt,wt[cnt]=a[now]; if(!ws[now]) return; dfs2(ws[now],tp); for(int i=bg[now];i;i=nx[i]) if(to[i]!=fa[now]&amp;&amp;to[i]!=ws[now]) dfs2(to[i],to[i]);&#125;inline void change(int x,int y,int z) &#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) &#123; assign(id[top[x]],id[x],z); x=fa[top[x]]; &#125; else &#123; assign(id[top[y]],id[y],z); y=fa[top[y]]; &#125; &#125; if(dep[x]&gt;dep[y]) assign(id[y],id[x],z); else assign(id[x],id[y],z);&#125;inline int query(int x,int y) &#123; int ans(0),lasta(0),lastb(0); IT itl,itr; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) &#123; itr=split(id[x]+1),itl=split(id[top[x]]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lasta) lasta=itr-&gt;v,++ans; if(itr==itl) break; &#125; x=fa[top[x]]; &#125; else &#123; itr=split(id[y]+1),itl=split(id[top[y]]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lastb) lastb=itr-&gt;v,++ans; if(itr==itl) break; &#125; y=fa[top[y]]; &#125; &#125; if(dep[x]&gt;dep[y]) &#123; itr=split(id[x]+1),itl=split(id[y]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lasta) lasta=itr-&gt;v,++ans; if(itr==itl) break; &#125; &#125; else &#123; itr=split(id[y]+1),itl=split(id[x]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lastb) lastb=itr-&gt;v,++ans; if(itr==itl) break; &#125; &#125; return ans-(lasta==lastb);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",a+i); for(int i=1;i&lt;n;++i) &#123; scanf("%d%d",&amp;x,&amp;y); link(x,y),link(y,x); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=n;++i) s.insert(node(i,i,wt[i])); while(m--) &#123; scanf("\n%c%d%d",&amp;opt,&amp;x,&amp;y); if(opt=='C') &#123; scanf("%d",&amp;z); change(x,y,z); &#125; else printf("%d\n",query(x,y)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>珂朵莉树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu1047]校门外的树]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu1047-%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[此处题面看见一堆 dalao 题解写树状数组线段树，蒟蒻在这里安利一种毒瘤数据结构——珂朵莉树。一、介绍。珂朵莉树 (ChthollyTree) ，又名 OldDriverTree (老司机树)，简称 ODT ，是一种非常暴力的数据结构，它将一段值相同的区间以三元组 &lt; 左端点，右端点，值 &gt; 的方式存储起来，因此它的效率是建立在区间推平操作 (assign) 上的(也就是本题的砍树)。二、存储方式。珂朵莉树的存储基于平衡树(我这里为了方便用了 STL 的 set )，这里定义珂朵莉树的结点为：1234567struct node &#123; int l,r,v; node(int L,int R=-1,int V=0):l(L),r(R),v(V) &#123;&#125; bool operator&lt;(const node&amp; x)const&#123; return l&lt;x.l; &#125;&#125;;这里的 l 和 r 是区间的左右端点(闭区间)，v 是该区间的值(表示这一区间内所有元素的值都是v)，然后是构造函数和重载运算符，这里重载成比较区间左端点。最后把区间扔进平衡树就行了：12set&lt;node&gt;s;typedef set&lt;node&gt;::iterator IT;三、核心操作。珂朵莉树的操作是基于一个核心操作 split 的，传入参数 pos 后，它能返回左端点值为 pos 的结点的迭代器，如果不存在这样的结点，它就会把包含 pos 的结点 &lt; l，r，v &gt; 拆成 &lt; l , pos-1 , v &gt; 和 &lt; pos , r , v &gt; ，然后返回后面这个结点的迭代器。先上代码：123456789IT split(int pos) &#123; IT it=s.lower_bound(node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; --it; int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v; s.erase(it); s.insert(node(L,pos-1,V)); return s.insert(node(pos,R,V)).first;&#125;一行行来看：1IT it=s.lower_bound(node(pos));lower_bound 是获取左端点大于等于 pos 的第一个结点。1if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it;如果这个结点的左端点正好是 pos ，我们就直接返回它。12--it;int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v;否则的话 —it 得到的就是包含 pos 的结点，我们用 L、R、V 储存它的左右端点和值。1s.erase(it);然后我们删掉这个结点。12s.insert(node(L,pos-1,V));return s.insert(node(pos,R,V)).first;最后我们插入两个新的结点，左右端点分别是 &lt; L、pos-1 &gt; 和 &lt; pos、R &gt; ，顺便返回后面这个结点的迭代器。这样我们就完成了 split 操作。四、区间推平。这是保证珂朵莉树复杂度不至于爆炸的重要操作，它能将一个区间内的值变得一样，本题的砍树就是区间赋值为 0 。先上代码：12345void assign(int l,int r,int v) &#123; IT itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;看上去十分的暴力，事实上珂朵莉树就是这么暴力的数据结构。稍微解释一下代码：1IT itl=split(l),itr=split(r+1);itl 指向的结点左端点为 l ，itr 指向的结点左端点为 r+1 。1s.erase(itl,itr);删去平衡树中 [ itl , itr ) 的结点(左闭右开区间)。1s.insert(node(l,r,v));直接插入一个 &lt; l , r &gt; ，值为v的区间。就是这么直接暴力！Upd：由于某些未知原因（珂学规定），珂朵莉树提取区间时需要先 split 右端点！五、其他操作。1. 初始化初始化操作就是直接插入，本题所有树默认都是种上的，全部赋值为 1 就行：1s.insert(node(0,l,1));2. 区间操作区间操作的话这里就以题目的求和为例，先上代码：1234567int sum(int l,int r) &#123; int _sum=0; IT itr=split(r+1),itl=split(l); for(;itl!=itr;++itl) _sum+=(itl-&gt;v)*((itl-&gt;r)-(itl-&gt;l)+1); return _sum;&#125;同样是非常的暴力，直接取出所有区间内的结点暴力求和就行了，其他的操作如区间加法乘法什么的也是一样的，取出结点遍历一遍就行。六、本题代码。最后放上本题AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;struct node &#123; int l,r,v; node(int L,int R=-1,int V=0):l(L),r(R),v(V) &#123;&#125; bool operator&lt;(const node&amp; x)const&#123; return l&lt;x.l; &#125;&#125;;int l,m,x,y,_sum;set&lt;node&gt;s;typedef set&lt;node&gt;::iterator IT;IT split(int pos) &#123; IT it=s.lower_bound(node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; --it; int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v; s.erase(it); s.insert(node(L,pos-1,V)); return s.insert(node(pos,R,V)).first;&#125;void remove(int l,int r) &#123; IT itl=split(l),itr=split(r+1); s.erase(itl,itr); s.insert(node(l,r,0));&#125;void sum() &#123; for(IT it=s.begin();it!=s.end();++it) _sum+=it-&gt;v*(it-&gt;r-it-&gt;l+1);&#125;int main() &#123; scanf("%d%d",&amp;l,&amp;m); s.insert(node(0,l,1)); for(int i=1;i&lt;=m;++i) &#123; scanf("%d%d",&amp;x,&amp;y); remove(x,y); &#125; sum(); printf("%d",_sum);&#125;七、总结珂朵莉树的效率建立在区间推平操作 (assign) 上，它能使结点数量快速减小从而保证时间复杂度，因此珂朵莉树十分容易被卡，不到万不得已还是得乖乖用别的数据结构，不过它的代码十分简单，考场上写不出别的数据结构时也是可以交一个珂朵莉树的。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
</search>
