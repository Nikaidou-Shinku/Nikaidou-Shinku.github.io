<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【讲课】8.2网络流]]></title>
    <url>%2F%E3%80%90%E8%AE%B2%E8%AF%BE%E3%80%918-2%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[8.2 网络流选讲菊开讲课，必属精品！[bzoj1280] $\text{Emmy}$卖猪pigs题面题目链接$\text{Emmy}$ 在一个养猪场工作。这个养猪场有 $m$ 个锁着的猪圈，但 $\text{Emmy}$ 并没有钥匙。有 $n$ 个顾客会到养猪场来买猪，一个接着一个。每一位顾客都会有一些猪圈的钥匙，他们会将这些猪圈打开并买走固定数目的猪。所有顾客有的钥匙和他们需要买猪的数量在事先都告诉了 $\text{Emmy}$，于是 $\text{Emmy}$ 要订一个计划，使得卖出去的猪最多。买卖的过程是这样的：一个顾客前来，并打开所有他可以打开的猪圈。然后 $\text{Emmy}$ 从这些猪圈里牵出固定数目的猪卖给顾客（最多只能和顾客需要数相等），并可以重新安排这些开着的猪圈中的猪。每个猪圈可以存放任意数目的猪。写一个程序，使得 $\text{Emmy}$ 能够卖出去尽可能多的猪。$n\leqslant100$ , $m\leqslant1000$题解暂咕T2题意给出一个 $n\times m$ 的矩阵，求一个 $n\times m$ 的值域为 $[L,R]$ 的矩阵 $B$ ，最小化下式的值：\large max= \begin{cases} \mathop{max}\limits_{1\leqslant j\leqslant m} \{|\sum_{i=1}^{n}{A_{ij}-B_{ij}}|\}\\ \mathop{max}\limits_{1\leqslant i\leqslant n} \{|\sum_{j=1}^{m}{A_{ij}-B_{ij}}|\} \end{cases}$n,m\leqslant 200$题解暂咕T3题意一个 $n\times m$ 的矩阵，每个点都有经过次数的下限一条路径从 $(1,1)$ 走到 $(n,m)$ ，路径中的点的行列坐标均满足单调不减最小化路径条数$n,m\leqslant1000$题解最长链等于最少反链覆盖每个点向不能到达它的点连边，跑最长路[bzoj1189] 紧急疏散evacuate题面题目链接发生了火警，所有人员需要紧急疏散！假设每个房间是一个 $n\times m$ 的矩形区域。每个格子可以是空地、墙或者门，人们可以从门撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。$3\leqslant n,m\leqslant20$题解对时间建分层图[POI2010] Bridges题面题目链接$\text{YYD}$ 为了减肥，他来到了瘦海，这是一个巨大的海，海中有 $n$ 个小岛，小岛之间有 $m$ 座桥连接，两个小岛之间不会有两座桥，并且从一个小岛可以到另外任意一个小岛。现在 $\text{YYD}$ 想骑单车从小岛 $1$ 出发，骑过每一座桥，到达每一个小岛，然后回到小岛 $1$ 。霸中同学为了让 $\text{YYD}$ 减肥成功，召唤了大风，由于是海上，风变得十分大，经过每一座桥都有不可避免的风阻碍 $\text{YYD}$ ， $\text{YYD}$ 十分 $ddt$ ，于是用泡芙贿赂了你，希望你能帮他找出一条承受的最大风力最小的路线。$2\leqslant n\leqslant1000$ , $1\leqslant m\leqslant2000$题解二分答案，网络流检验先随机定向，检查每个点的度数对于一个点入度减出度为正的，源点向其连边，否则该点向汇点连边边权为度数差的绝对值[bzoj4213] 贪吃蛇题面题目链接最近 $\text{lwher}$ 迷上了贪吃蛇游戏，在玩了几天却从未占满全地图的情况下，他不得不承认自己是一个弱菜，只能改去开发一款更弱的贪吃蛇游戏。在开发的过程中， $\text{lwher}$ 脑洞大开，搞了一个多条蛇的模式。但由于这种模式太难操作，于是他只好改变游戏的玩法，稍微变化一下游戏目标。新的游戏是这样的：一些蛇覆盖了一个网格。每个格子要么是一个障碍物，要么是蛇的一部分。每条蛇占据了一条折线（拐角处只能水平和竖直连接），且至少占据两个格子。蛇与蛇之间不能重叠，蛇也不会与自己重叠。每条蛇还必须满足以下两个条件中的一个：两个端点所在的格子在网格的边界。蛇构成一个环，即两个端点相邻（垂直或水平，不能斜着），至少要占据 $4$ 个格子（否则没法形成环）。给定一个网格，在满足前面所述的条件下覆盖所有空地，并使得端点在网格边界（即不构成环）的蛇尽量少。（如果一条蛇既构成环，又是端点在边界，那么不计入答案）例如，以下网格：可以由下面三种方案覆盖。还有其它的方案，但是没法仅用一条不构成环的蛇就覆盖整个网格。$n,m\leqslant12$题解黑白染色，边界的点下界为 $1$ ，上界为 $2$内部的点上下界皆为 $2$ ，障碍不连边[CEOI2008] order题面题目链接有 $n$ 个工作， $m$ 种机器，每种机器你可以租或者买过来。每个工作包括若干道工序，每道工序需要某种机器来完成，你可以通过购买或租用机器来完成。现在给出这些参数，求最大利润。$1\leqslant n,m\leqslant1200$题解源点向工作连收益工作向机器连租的价格机器向汇点连买的价格用总收益减去最小割[bzoj3774] 最优选择题面题目链接小 $\text{N}$ 手上有一个 $n\times m$ 的方格图，控制某一个点要付出 $A_{ij}$ 的代价，然后某个点如果被控制了，或者它周围的所有点（上下左右）都被控制了，那么它就算是被选择了的。一个点如果被选择了，那么可以得到 $B_{ij}$ 的回报。现在请你帮小 $\text{N}$ 选一个最优的方案，使得回报减代价尽可能大。$n,m\leqslant 50$题解暂咕T9题意$p\times q$ 的网格，每个位置有 $r$ 种选择，编号为 $1\sim r$ ，每种选择都有对应收益（可能为负）限制每个点分别和它上下左右相邻的 $4$ 个点的选择编号之和不能超过 $d$最大化总收益$p,q,r\leqslant40$题解暂咕]]></content>
      <tags>
        <tag>讲课</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu3383]线性筛素数]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu3383-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[此处题面前言首先说一下，这个科技是我在 $\text{Min_25}$ 的博客里看见的，那篇博客是 $2017$ 年的了，去翻了下提交记录发现论文哥也用了这个科技，所以也并不是什么新东西。有兴趣的也可以去阅读一下那篇博客。然后，虽然这个题是线性筛素数，但是这篇题解并不是讲筛法的，而是一些奇技淫巧。若是想学习素数筛法的可以跳过这篇题解了。正文相信各位都知道一个 $O(\sqrt n)$ 判断素数的方法，也就是枚举 $2\sim\lfloor\sqrt n\rfloor$ 检查每个数是否是 $n$ 的约数。具体代码如下：123456bool check(int x) &#123; if(x==0||x==1) return false; for(int i=2;i*i&lt;=x;++i) if(x%i==0) return false; return true;&#125;这个题我们只要对于每个询问都这样判断一次即可，复杂度上界 $O(M\sqrt N)$ 。如果我的数据是 $10^6$ 个 $9840769$ ，并且你的程序没有记忆化，这个程序需要 $\text{7.7s}$ 左右的时间才能出解。我们考虑怎样优化。我们判断约数的时候需要取模，而众所周知 $\text{C++}$ 的取模是很慢的，如果能加快取模的效率，就能对运行速度有很大优化。$\text{Min_25}$ 在他的博客里讲到了这样一种优化方法：考虑到判断约数时我们只需要得知取模结果是否为 $0$ ，并不需要知道实际结果。若 $m$ 为奇数， $m’$ 为 $m$ 模 $2^{64}$ 下的逆元，且有 $n\in\left[0,2^{64}\right)$ ，则：n\equiv0\pmod{m}\ \Leftrightarrow\ (n\cdot m')\%2^{64}\leqslant\lfloor\frac{2^{64}}{m}\rfloor对于一个模数 $m$ 我们预处理出 $m’$ 和 $\lfloor\frac{2^{64}}{m}\rfloor$ ，然后我们就可以把判断 $n\%m$ 是否为 $0$ 转化为一次乘法和一次比较大小。使用这个方法，刚刚跑 $\text{7.7s}$ 的程序只需要 $\text{1.9s}$ 即可出解， $4$ 倍的效率优化！最后这个技巧不仅可以用于判断素数，也可以用于质因数分解，杜教筛、洲阁筛、 $\text{Min_25}$ 筛的预处理。但使用场合还是较少，不过效率优化还是十分明显的！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu5373]多项式复合函数]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu5373-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[此处题面前言这是这道题复杂度比较正确的一个常数奇大无比的算法，源自 $\text{R.P.BRENT}$ 和 $\text{H.T.KUNG}$ 在 $1978$ 年发表的论文（也就是题面里说的那个全嘤文pdf），我在 $\text{5月15日}$ 蒯到手之后肝了一个晚上，在神犇 rqy 的帮助下成功地写出了66分点名被卡做法awsl，后来研究别人代码的时候发现了 预处理原根 这种神奇操作，于是总算成功AC。正文这种做法基于对外层函数的泰勒展开，我们把内层函数 $G$ 的前 $m$ 项拆出来，记作 $G_m$ ，把剩下的记作 $G_r$ 。(这个 $m$ 到底取多少我们分析复杂度的时候再确定)然后进行泰勒展开：F(G)=F(G_m+G_r)=F(G_m)+F'(G_m)G_r+\frac12F''(G_m)G_r^2+\cdots由于我们只需要求 $F(G)$ 前 $n+1$ 项的值，所以我们只需要知道这个展开式前 $\lceil\frac nm\rceil$ 项的值即可，即：令 $l=\lceil\frac nm\rceil$ ，有F(G(x))\equiv F(G_m(x))+F'(G_m(x))G_r(x)+\cdots+\frac1{l!}F^{(l)}(G_m(x))G_r^l(x)\pmod{x^{n+1}}因此我们只要计算出 $F(G_m(x))$ 的各阶导和 $G_r(x)$ 的各次幂，就可以累加得到 $F(G(x))$ 了。$G_r(x)$ 只需要从 $G(x)$ 中截出来即可，那么如何计算 $F(G_m(x))$ 呢？考虑外层函数最高次项次数为 $2$ 的幂的情况，即：令 $F(x)=f_0+\cdots+f_jx^j$ 且 $j$ 为 $2$ 的正整数次幂，有F(G)=F_1(G)+G^{\frac j2}\cdot F_2(G)这里 $F_1$ 和 $F_2$ 都是最高次项次数为 $\frac j2$ 的多项式，这样一来我们就能递归地计算 $F(G_m(x))$ 了。考虑这一步的时间复杂度：我们令 $M(n)$ 为完成两个 $n$ 次多项式的乘法的时间，即： $M(n)=O(n\log n)$我们设 $T(j)$ 为计算 $G^{\frac j2}$ 和 $F(G)$ 的时间，则有T(j)\leqslant2T(\frac j2)+O(M(\min(jm,n)))我们令 $r$ 为满足 $n\cdot2^k\leqslant jm$ 的最大的 $k$ ，则有T(j)=O(M(n)+2M(n)+\cdots+2^rM(n))+2^{r+1}T(\frac{j}{2^{r+1}})T(j)\leqslant O(\frac{jmM(n)}{n})+(\frac{2jm}{n})T(\frac{j}{2^{r+1}})又因为 $n\cdot2^{r+1}&gt;jm$ ，有T(\frac{j}{2^{r+1}})=O(M(\frac{jm}{2^{r+1}})+2M(\frac{jm}{2^{r+2}})+\cdots)=O(M(n)+2M(\lceil\frac n2\rceil)+4M(\lceil\frac n4\rceil)+\cdots)=O(\log nM(n))因此，我们有 $T(j)=O(\frac{jm\log n}{n}M(n))$ ，所以求解 $F(G_m(x))$ 的时间复杂度为 $O(mn\log^2n)$ 。我们再来考虑对 $F(G_m(x))$ 求导：令 $H(x)=F(G(x))$根据复合函数求导法则，我们有 $H’(x)=F’(G(x))\cdot G’(x)$ ，因此 $F’(G_m(x))=H’(x)\cdot(G_m’(x))^{-1}$ ，由此我们可以计算出泰勒展开式中某一项之后与之前的结果累加得到 $H(x)$ ，同时计算出下一项中 $F(G_m(x))$ 的对应阶导。每计算一次导数的时间复杂度是 $O(n\log n)$ 的，因此计算出所有项的时间复杂度是 $O(l\cdot n\log n)=O(\frac{n^2\log n}{m})$ 。我们已经得到了 $F(G_m(x))$ 的各阶导，而 $G_r(x)$ 的各次幂只需要挨个乘起来即可，时间复杂度也是 $O(\frac{n^2\log n}{m})$ 的。之后各项的计算和累加同样是 $O(\frac{n^2\log n}{m})$ 的，因此这个算法的总复杂度为 $O(mn\log^2n+\frac{n^2\log n}{m})$ 。我们考虑 $m$ 的取值：根据均值不等式，当 $mn\log^2n\sim\frac{n^2\log n}{m}$ 时时间复杂度最优，因此解得当 $m\sim\sqrt{\frac{n}{\log n}}$ 时有最优时间复杂度 $O((n\log n)^{1.5})$ 。最后还是附上参考代码比较好，这个东西由于常数原因必须 预处理原根 才能卡过去，而且好像也没有什么实际用处。。就当是练习码力了 2333123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#pragma GCC optimize("Ofast,inline")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native")#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define MOD 998244353#define G 332748118#define N 262210#define re register#define gc pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++typedef long long ll;static char buf[100000],*pa(buf),*pb(buf);static char pbuf[3000000],*pp(pbuf),st[15];inline int read() &#123; re int x(0);re char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48,c=gc; return x;&#125;inline void write(re int v) &#123; if(v==0) *pp++=48; else &#123; re int tp(0); while(v) st[++tp]=v%10+48,v/=10; while(tp) *pp++=st[tp--]; &#125; *pp++=32;&#125;inline int pow(re int a,re int b) &#123; re int ans(1); while(b) ans=b&amp;1?(ll)ans*a%MOD:ans,a=(ll)a*a%MOD,b&gt;&gt;=1; return ans;&#125;int inv[N],ifac[N];inline void pre(re int n) &#123; inv[1]=ifac[0]=1; for(re int i(2);i&lt;=n;++i) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD; for(re int i(1);i&lt;=n;++i) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;&#125;inline int getLen(re int t) &#123; return 1&lt;&lt;(32-__builtin_clz(t));&#125;int lmt(1),r[N],w[N];inline void init(re int n) &#123; re int l(0); while(lmt&lt;=n) lmt&lt;&lt;=1,++l; for(re int i(1);i&lt;lmt;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); re int wn(pow(3,(MOD-1)/lmt)); w[lmt&gt;&gt;1]=1; for(re int i((lmt&gt;&gt;1)+1);i&lt;lmt;++i) w[i]=(ll)w[i-1]*wn%MOD; for(re int i((lmt&gt;&gt;1)-1);i;--i) w[i]=w[i&lt;&lt;1];&#125;inline void DFT(int*a,re int l) &#123; static unsigned long long tmp[N]; re int u(__builtin_ctz(lmt)-__builtin_ctz(l)),t; for(re int i(0);i&lt;l;++i) tmp[i]=(a[r[i]&gt;&gt;u])%MOD; for(re int i(1);i&lt;l;i&lt;&lt;=1) for(re int j(0),step(i&lt;&lt;1);j&lt;l;j+=step) for(re int k(0);k&lt;i;++k) t=(ll)w[i+k]*tmp[i+j+k]%MOD, tmp[i+j+k]=tmp[j+k]+MOD-t, tmp[j+k]+=t; for(re int i(0);i&lt;l;++i) a[i]=tmp[i]%MOD;&#125;inline void IDFT(int*a,re int l) &#123; std::reverse(a+1,a+l);DFT(a,l); re int bk(MOD-(MOD-1)/l); for(re int i(0);i&lt;l;++i) a[i]=(ll)a[i]*bk%MOD;&#125;int n,m;int a[N],b[N],c[N];void getInv(int*a,int*b,int deg) &#123; if(deg==1) b[0]=pow(a[0],MOD-2); else &#123; static int tmp[N]; getInv(a,b,(deg+1)&gt;&gt;1); re int l(getLen(deg&lt;&lt;1)); for(re int i(0);i&lt;l;++i) tmp[i]=i&lt;deg?a[i]:0; DFT(tmp,l),DFT(b,l); for(re int i(0);i&lt;l;++i) b[i]=(2ll-(ll)tmp[i]*b[i]%MOD+MOD)%MOD*b[i]%MOD; IDFT(b,l); for(re int i(deg);i&lt;l;++i) b[i]=0; &#125;&#125;inline void getDer(int*a,int*b,int deg) &#123; for(re int i(0);i+1&lt;deg;++i) b[i]=(ll)a[i+1]*(i+1)%MOD; b[deg-1]=0;&#125;void getComp(int*a,int*b,int k,int m,int&amp;n,int*c,int*d) &#123; if(k==1) &#123; for(re int i(0);i&lt;m;++i) c[i]=0,d[i]=b[i]; n=m,c[0]=a[0]; &#125; else &#123; static int t1[N],t2[N]; int nl(n),nr(n),*cl,*cr,*dl,*dr; getComp(a,b,k&gt;&gt;1,m,nl,cl=c,dl=d); getComp(a+(k&gt;&gt;1),b,(k+1)&gt;&gt;1,m,nr,cr=c+nl,dr=d+nl); n=std::min(n,nl+nr-1); re int _l(getLen(nl+nr)); for(re int i(0);i&lt;_l;++i) t1[i]=i&lt;nl?dl[i]:0; for(re int i(0);i&lt;_l;++i) t2[i]=i&lt;nr?cr[i]:0; DFT(t1,_l),DFT(t2,_l); for(re int i(0);i&lt;_l;++i) t2[i]=(ll)t1[i]*t2[i]%MOD; IDFT(t2,_l); for(re int i(0);i&lt;n;++i) c[i]=((i&lt;nl?cl[i]:0)+t2[i])%MOD; for(re int i(0);i&lt;_l;++i) t2[i]=i&lt;nr?dr[i]:0; DFT(t2,_l); for(re int i(0);i&lt;_l;++i) t2[i]=(ll)t1[i]*t2[i]%MOD; IDFT(t2,_l); for(re int i(0);i&lt;n;++i) d[i]=t2[i]; &#125;&#125;inline void getComp(int*a,int*b,int*c,int deg) &#123; static int ts[N],ps[N],c0[N],_t1[N],idM[N]; int M(std::max((int)ceil(sqrt(deg/log2(deg))*2.5),2)),_n(deg+deg/M); getComp(a,b,deg,M,_n,c0,_t1); re int _l(getLen(_n+deg)); for(re int i(_n);i&lt;_l;++i) c0[i]=0; for(re int i(0);i&lt;_l;++i) ps[i]=i==0; for(re int i(0);i&lt;_l;++i) ts[i]=M&lt;=i&amp;&amp;i&lt;deg?b[i]:0; getDer(b,_t1,M); for(re int i(M-1);i&lt;deg;++i) _t1[i]=0; /// Important!!! getInv(_t1,idM,deg); for(int i=deg;i&lt;_l;++i) idM[i]=0; DFT(ts,_l),DFT(idM,_l); for(re int t(0);t*M&lt;deg;++t) &#123; for(re int i(0);i&lt;_l;++i) _t1[i]=i&lt;deg?c0[i]:0; DFT(ps,_l),DFT(_t1,_l); for(re int i(0);i&lt;_l;++i) _t1[i]=(ll)_t1[i]*ps[i]%MOD, ps[i]=(ll)ps[i]*ts[i]%MOD; IDFT(ps,_l),IDFT(_t1,_l); for(re int i(deg);i&lt;_l;++i) ps[i]=0; for(re int i(0);i&lt;deg;++i) c[i]=((ll)_t1[i]*ifac[t]+c[i])%MOD; getDer(c0,c0,_n); for(re int i(_n-1);i&lt;_l;++i) c0[i]=0; DFT(c0,_l); for(re int i(0);i&lt;_l;++i) c0[i]=(ll)c0[i]*idM[i]%MOD; IDFT(c0,_l); for(re int i(_n-1);i&lt;_l;++i) c0[i]=0; &#125;&#125;int main() &#123; n=read(),m=read(); for(re int i(0);i&lt;=n;++i) a[i]=read(); for(re int i(0);i&lt;=m;++i) b[i]=read(); m=(n&gt;m?n:m)+1; pre(m);init(m*5); getComp(a,b,c,m); for(re int i(0);i&lt;=n;++i) write(c[i]); fwrite(pbuf,1,pp-pbuf,stdout); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu5431]乘法逆元2]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu5431-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%832%2F</url>
    <content type="text"><![CDATA[此处题面题外话其实我觉得这道题的考点是快读.jpg没有快读的后果正文\large\text{以下运算均在模 }p\text{ 意义下进行}\large\sum_{i=1}^{n}{\frac{k^i}{a_i}}=\sum_{i=1}^{n}{k^i\cdot a_i^{-1}}我们考虑先求出 $a$ 序列的前缀积，记为 $s$ ：\large s_i=\prod_{j=1}^{i}{a_j}记 $a$ 序列前缀积的逆元为 $t$ ，此时如果我们知道这个序列，我们就可以知道 $a$ 中任意一个数的逆元：\large a_i^{-1}=s_{i-1}\cdot t_i而 前缀积的逆元 就等于 逆元的前缀积 ，所以我们只要求出 $t_n$ 就可以线性递推出整个 $t$ 序列了：\large t_n=s_n^{p-2}\large t_i=a_{i+1}\cdot t_{i+1}这样我们就求得了 $a$ 序列的逆元，再用秦九韶算法就能在线性时间内算出题目的式子了。参考代码前方极差码风警告！123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#define N 5000010#define re register#define gc pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++typedef long long ll;static char buf[100000],*pa(buf),*pb(buf);inline int read() &#123; re int x(0);re char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48,c=gc; return x;&#125;inline int pow(int a,int b,int p) &#123; int ans(1); while(b) ans=b&amp;1?(ll)ans*a%p:ans,a=(ll)a*a%p,b&gt;&gt;=1; return ans;&#125;int n,p,k,a[N],s[N]=&#123;1&#125;,inv_s[N],ans;int main() &#123; n=read(),p=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(),s[i]=(ll)s[i-1]*a[i]%p; inv_s[n]=pow(s[n],p-2,p); for(int i=n-1;i;--i) inv_s[i]=(ll)inv_s[i+1]*a[i+1]%p; for(int i=n;i;--i) ans=((ll)inv_s[i]*s[i-1]%p+ans)*k%p; printf("%d",ans); return 0;&#125;5e6 的输入，千万记得快读！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu4315]月下“毛景树”]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu4315-%E6%9C%88%E4%B8%8B%E2%80%9C%E6%AF%9B%E6%99%AF%E6%A0%91%E2%80%9D%2F</url>
    <content type="text"><![CDATA[此处题面前言这道题其实就是把 单点修改 、 区间染色 、 区间加 以及 区间最大值 这四种基本的序列操作出到了树上，很明显是用 树链剖分 + 线段树 解决，但是因为我太蒻了，树剖码到一半码不下去了，所以就全删了改码了个 Link/Cut Tree ，顺便 拿了这个题的RANK1 。边转点树剖的边转点大家都知道是把每条边的权值给深度较深的那个点，但是我们不能在 LCT 上也这么做，因为有 makeroot 操作的存在， LCT 上结点的父子关系不是确定的，所以我们采取建立 虚拟结点 的方式：1234// 第 i 条边连接 u 和 v 这两个点，权值为 wval[n+i]=maxv[n+i]=w;link(u,n+i);link(n+i,v);用 $n$ + $i$ 号结点表示第 $i$ 条边，再用它去分别连接原先的边连接的结点。需要注意的地方这种写法会产生 $2n$ 个结点， 空间千万要开够！标记上传下传的时候要分 原结点 和 虚拟结点 两种情况讨论！标记这道题我们只需要维护一个 区间染色 的标记和一个 区间加 的标记就行，我多维护了一个 siz 数组储存子树内 虚拟结点 的数量，上传时判断当前结点是不是 虚拟结点 就行。标记下传的时候要 先下传区间染色，再下传区间加 ，若是先下传了 区间加 ，后面 区间染色 的时候就会 覆盖掉最后附上此题 $AC$ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#define N 200010#define lc(x) ch[x][0]#define rc(x) ch[x][1]#define re register#define gc pa==pb&amp;&amp;(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++inline int max(int a,int b)&#123;return b&lt;a?a:b;&#125;inline void swap(int&amp;a,int&amp;b)&#123;int tmp(a);a=b,b=tmp;&#125;static char buf[100000],*pa(buf),*pb(buf);static char pbuf[3000000],*pp(pbuf),st[15];inline char gtc() &#123; re char c(gc); while(c!='S'&amp;&amp;c!='h'&amp;&amp;c!='o'&amp;&amp;c!='d'&amp;&amp;c!='a') c=gc; return c;&#125;inline int read() &#123; re int x(0);re char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48,c=gc; return x;&#125;inline void write(re int v) &#123; if(!v) *pp++=48; else &#123; re char*tp(st); while(v) *++tp=v%10+48,v/=10; while(tp!=st) *pp++=*tp--; &#125; *pp++='\n';&#125;int n,u,v,w;char opt;int ch[N][2],fa[N],rev[N],val[N],maxv[N],ass[N],addv[N],siz[N];inline void assign(int x,int y)&#123;val[x]=x&gt;n?y:0,maxv[x]=siz[x]&gt;0?y:0,addv[x]=0,ass[x]=y;&#125;inline void add(int x,int y)&#123;val[x]+=x&gt;n?y:0,maxv[x]+=siz[x]&gt;0?y:0,addv[x]+=siz[x]&gt;0?y:0;&#125;inline void up(int x)&#123;siz[x]=siz[lc(x)]+siz[rc(x)]+(x&gt;n),maxv[x]=max(val[x],max(maxv[lc(x)],maxv[rc(x)]));&#125;inline void down(int x) &#123; if(rev[x]) rev[lc(x)]^=1,rev[rc(x)]^=1,rev[x]=0,swap(lc(x),rc(x)); if(ass[x]) assign(lc(x),ass[x]),assign(rc(x),ass[x]),ass[x]=0; if(addv[x]) add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;&#125;inline int nrt(int x)&#123;return x==lc(fa[x])||x==rc(fa[x]);&#125;void psa(int x)&#123;if(nrt(x))psa(fa[x]);down(x);&#125;inline void rotate(int x) &#123; int y(fa[x]),z(fa[y]),k(x==rc(y)); ch[y][k]=ch[x][k^1],ch[x][k^1]=y;if(nrt(y))ch[z][y==rc(z)]=x; if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z,up(y);&#125;inline void splay(int x) &#123; int y,z; for(psa(x);nrt(x);rotate(x)) &#123;y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);&#125;up(x);&#125;inline void access(int x)&#123;for(int y(0);x;x=fa[y=x])splay(x),rc(x)=y,up(x);&#125;inline void mrt(int x)&#123;access(x),splay(x),rev[x]^=1;&#125;inline void split(int x,int y)&#123;mrt(x),access(y),splay(y);&#125;inline void link(int x,int y)&#123;mrt(x),fa[x]=y;&#125;int main() &#123; n=read(); for(re int i(1);i&lt;n;++i) siz[n+i]=1; for(re int i(1);i&lt;n;++i) u=read(),v=read(),val[n+i]=maxv[n+i]=read(),link(u,n+i),link(n+i,v); opt=gtc(); while(opt!='S') &#123; u=read(),v=read(); switch(opt) &#123; case'h': access(n+u),splay(n+u),val[n+u]=v; break; case'o': split(u,v),assign(v,read()); break; case'd': split(u,v),add(v,read()); break; case'a': split(u,v),write(maxv[v]); &#125; opt=gtc(); &#125; fwrite(pbuf,1,pp-pbuf,stdout); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Link/Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】学习资料]]></title>
    <url>%2F%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[收集的一些资料，留给自己慢慢啃。各路OJ洛谷、bzoj、POJ、UOJ、LibreOJ、51Nod、OIH、评测鸭、hihoCoder、OHO-OJ、Vijos、ZHZXOJ、ZOJ博文索引yzhang、bztMinamoto、自为风月马前卒、JasonZhan、huyufeifei、xehoth、饕餮传奇、Venus、yyb、rqy、Mrsrz、xht37、Victor、fcwww、EI、诗乃、Siyuan数据结构猫树、zkw线段树、Leafy Tree、Link-Cut Tree、树套树、后缀数组、回文自动机算法分治、动态dp、生成函数其它OI Wiki、算法可视化、SAM可视化、题号查找器、图可视化、OEIS、MaHua在线Markdown编辑器、矩阵乘法、图床搭建、MiNa]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu3372]线段树1]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu3372-%E7%BA%BF%E6%AE%B5%E6%A0%911%2F</url>
    <content type="text"><![CDATA[此处题面去了 WC2019 的同学应该对 指令集 有些印象，没去的同学 ( 比如我 ) 可能也通过一些途径了解到了这个暴力踩标程的毒瘤 ( 据说现场踩 Ynoi五彩斑斓的世界 ) 。但是由于我太弱，实在过不了那道题 dllxl Orz ，所以我就来拿这道题练手了。一、指令集是什么？其实就是压位，常用的是压256位。也有能压512位的，但大部分情况不支持 ( 硬件 + 软件 ) 。二、它为什么快？就像压位高精会比裸高精快， bitset 比 bool数组 快一样，你把8个32位的 int 压成一个256位的玩意儿，每次操作可以看成是同时对8个 int 进行操作 ( 但其实并不是这样 ) ，所以理论上常数会是原来的 $\frac{1}{8}$ ( 但其实做不到 $\frac{1}{8}$ ) 。三、它要怎么用？请自行摸索首先你需要 immintrin.h 库，里面啥都有然后再在程序前加上 #pragma GCC target(&quot;avx,avx2&quot;) ，这样你就可以把你的 int 啊 long long 啊什么的压成 __m256i ，把 float 压成 __m256 ，还能把 double 压成 __m256d 。什么你问我具体怎么做？我不知道啊.jpg这里是连快读都没用的$O\left(n^2\right)$暴力评测记录。最后附上这道题的程序，想学学指令集的可以看看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#pragma GCC optimize("Ofast,fast-math")#pragma GCC target("avx,avx2")#include &lt;cstdio&gt;#include &lt;immintrin.h&gt;int n,m,num,x[5],opt,p,q,k;__m256i a[25010];inline void add(int l,int r,int v) &#123; while(((l-1)&amp;3)&amp;&amp;l&lt;=r)((long long*)(a+(l&gt;&gt;2)+1))[(l&amp;3)-1]+=v,++l; if(l==r+1)return; while((r&amp;3)&amp;&amp;l&lt;=r)((long long*)(a+(r&gt;&gt;2)+1))[(r&amp;3)-1]+=v,--r; if(l==r+1)return; l=(l&gt;&gt;2)+1,r&gt;&gt;=2; __m256i s=_mm256_set_epi64x(v,v,v,v); while(l&lt;=r)a[l]=_mm256_add_epi64(a[l],s),++l;&#125;inline long long query(int l,int r) &#123; long long ans(0); while(((l-1)&amp;3)&amp;&amp;l&lt;=r)ans+=((long long*)(a+(l&gt;&gt;2)+1))[(l&amp;3)-1],++l; if(l==r+1)return ans; while((r&amp;3)&amp;&amp;l&lt;=r)ans+=((long long*)(a+(r&gt;&gt;2)+1))[(r&amp;3)-1],--r; if(l==r+1)return ans; l=(l&gt;&gt;2)+1,r&gt;&gt;=2; __m256i s=_mm256_set_epi64x(0,0,0,0); while(l&lt;=r)s=_mm256_add_epi64(a[l],s),++l; for(int i=0;i&lt;4;++i) ans+=((long long*)&amp;s)[i]; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m);num=n&gt;&gt;2; for(int i=1;i&lt;=num;++i) &#123; for(int j=1;j&lt;=4;++j) scanf("%d",x+j); a[i]=_mm256_set_epi64x(x[4],x[3],x[2],x[1]); &#125; for(int i=1;i&lt;=(n&amp;3);++i) scanf("%d",x+i); a[++num]=_mm256_set_epi64x(x[4],x[3],x[2],x[1]); while(m--) &#123; scanf("%d%d%d",&amp;opt,&amp;p,&amp;q); if(opt==1) scanf("%d",&amp;k),add(p,q,k); else printf("%lld\n",query(p,q)); &#125; return 0;&#125;这道题要开 long long ，如果是 int 的话程序第一句的 Ofast 优化去掉也能过！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[JLOI2014]松鼠的新家]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-JLOI2014-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[此处题面由于树上两点路径唯一，维尼的路线也是唯一的，因此我们只要 统计维尼经过每个点的次数 即可。而树上路径又跟 LCA 什么的有关，因此这道题的做法就多种多样了。由于只有一次询问，比较容易想到的做法是 树上差分 后求 LCA 轻松搞定。再想深一点你会发现这道题简直就是 树链剖分 的板子，再加上这道题不用维护什么子树信息，所以 树链剖分 能做 Link/Cut Tree 当然也能做！需要注意的几点：这道题 LCT 得卡常，写的时候注意不要太飘；由于两条链相交的点会被重复计算，因此每次加的时候链头链尾要有一个减 1 (我是链尾)；最后一个点是不需要准备糖果的！输出答案的时候记得把标记都下放了 (我是先 makeroot 再输出) 。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#define N 300010#define lc(x) ch[x][0]#define rc(x) ch[x][1]#define re registerinline void swap(re int&amp;a,re int&amp;b)&#123;re int tmp(a);a=b,b=tmp;&#125;int ch[N][2],fa[N],rev[N],val[N],addv[N];inline void add(re int x,re int y)&#123;val[x]+=y,addv[x]+=y;&#125;inline void down(re int x) &#123; if(rev[x]) rev[lc(x)]^=1,rev[rc(x)]^=1,swap(lc(x),rc(x)),rev[x]=0; if(addv[x]) add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;&#125;inline int nrt(re int x)&#123;return x==lc(fa[x])||x==rc(fa[x]);&#125;void psa(int x)&#123;if(nrt(x))psa(fa[x]);down(x);&#125;inline void rotate(re int x) &#123; re int y(fa[x]),z(fa[y]),k(x==rc(y)); ch[y][k]=ch[x][!k],ch[x][!k]=y;if(nrt(y))ch[z][y==rc(z)]=x; if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z;&#125;inline void splay(re int x) &#123; re int y,z; for(psa(x);nrt(x);rotate(x)) &#123;y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);&#125;&#125;inline void access(re int x)&#123;for(re int y(0);x;x=fa[y=x])splay(x),rc(x)=y;&#125;inline void mrt(re int x)&#123;access(x),splay(x),rev[x]^=1;&#125;inline void link(re int x,re int y)&#123;mrt(x),fa[x]=y;&#125;int n,a[N],x,y;int main() &#123; scanf("%d",&amp;n); for(re int i(1);i&lt;=n;++i) scanf("%d",a+i); for(re int i(1);i&lt;n;++i) scanf("%d%d",&amp;x,&amp;y),link(x,y); for(re int i(1);i&lt;n;++i) --val[a[i+1]],mrt(a[i]),access(a[i+1]),splay(a[i+1]),add(a[i+1],1); for(re int i(1);i&lt;=n;++i) mrt(i),printf("%d\n",val[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Link/Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[SDOI2011]染色]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-SDOI2011-%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[此处题面这道题的做法其实已经很明显了， 树链剖分 + 线段树 ，只是看到区间赋值心血来潮想用 珂朵莉树 水，结果就过了╮(╯▽╰)╭操作 1 就是 区间推平 ( assign ) ，操作 2 可以像找 最近公共祖先 ( LCA ) 一样一边往上方跳一边统计，由于珂朵莉树的结点存储的是一段值相同的连续区间，我们只需要记录上一次访问的结点的值与当前结点的值比较，若不同则更新并计数。值得注意的 $3$ 点：由于我们是统计链上的连续段，所以我们应从深度大的结点往小的枚举。由于我们是从链的两端分别往上跳，所以我们需要分别记录两边上次访问的结点的值。最后处于同一条链上时，需要考虑两端的值相同的情况。最后放上 $AC$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;set&gt;using std::set;#define N 100010struct node &#123; int l,r,v; node(int L,int R=-1,int V=0):l(L),r(R),v(V)&#123;&#125; inline int operator&lt;(const node&amp;x)const&#123;return l&lt;x.l;&#125;&#125;;set&lt;node&gt;s;typedef set&lt;node&gt;::iterator IT;inline IT split(int pos) &#123; IT it(--s.upper_bound(node(pos))); if(it-&gt;l==pos) return it; int L(it-&gt;l),R(it-&gt;r),V(it-&gt;v); s.erase(it),s.insert(node(L,pos-1,V)); return s.insert(node(pos,R,V)).first;&#125;inline void assign(int l,int r,int v) &#123; IT itr(split(r+1)),itl(split(l)); s.erase(itl,itr);s.insert(node(l,r,v));&#125;int n,m,a[N],x,y,z;char opt;int e,bg[N],nx[N&lt;&lt;1],to[N&lt;&lt;1];inline void link(int u,int v)&#123;to[++e]=v,nx[e]=bg[u],bg[u]=e;&#125;int fa[N],dep[N],siz[N],ws[N];void dfs1(int now,int f) &#123; fa[now]=f,dep[now]=dep[f]+1,siz[now]=1; int mx(-1); for(int i=bg[now];i;i=nx[i]) if(to[i]!=f) &#123; dfs1(to[i],now); siz[now]+=siz[to[i]]; if(siz[to[i]]&gt;mx) mx=siz[to[i]],ws[now]=to[i]; &#125;&#125;int cnt,top[N],id[N],wt[N];void dfs2(int now,int tp) &#123; top[now]=tp,id[now]=++cnt,wt[cnt]=a[now]; if(!ws[now]) return; dfs2(ws[now],tp); for(int i=bg[now];i;i=nx[i]) if(to[i]!=fa[now]&amp;&amp;to[i]!=ws[now]) dfs2(to[i],to[i]);&#125;inline void change(int x,int y,int z) &#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) &#123; assign(id[top[x]],id[x],z); x=fa[top[x]]; &#125; else &#123; assign(id[top[y]],id[y],z); y=fa[top[y]]; &#125; &#125; if(dep[x]&gt;dep[y]) assign(id[y],id[x],z); else assign(id[x],id[y],z);&#125;inline int query(int x,int y) &#123; int ans(0),lasta(0),lastb(0); IT itl,itr; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) &#123; itr=split(id[x]+1),itl=split(id[top[x]]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lasta) lasta=itr-&gt;v,++ans; if(itr==itl) break; &#125; x=fa[top[x]]; &#125; else &#123; itr=split(id[y]+1),itl=split(id[top[y]]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lastb) lastb=itr-&gt;v,++ans; if(itr==itl) break; &#125; y=fa[top[y]]; &#125; &#125; if(dep[x]&gt;dep[y]) &#123; itr=split(id[x]+1),itl=split(id[y]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lasta) lasta=itr-&gt;v,++ans; if(itr==itl) break; &#125; &#125; else &#123; itr=split(id[y]+1),itl=split(id[x]); for(--itr;;--itr) &#123; if(itr-&gt;v!=lastb) lastb=itr-&gt;v,++ans; if(itr==itl) break; &#125; &#125; return ans-(lasta==lastb);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%d",a+i); for(int i=1;i&lt;n;++i) &#123; scanf("%d%d",&amp;x,&amp;y); link(x,y),link(y,x); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=n;++i) s.insert(node(i,i,wt[i])); while(m--) &#123; scanf("\n%c%d%d",&amp;opt,&amp;x,&amp;y); if(opt=='C') &#123; scanf("%d",&amp;z); change(x,y,z); &#125; else printf("%d\n",query(x,y)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>珂朵莉树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[Luogu1047]校门外的树]]></title>
    <url>%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu1047-%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[此处题面看见一堆 dalao 题解写树状数组线段树，蒟蒻在这里安利一种毒瘤数据结构——珂朵莉树。一、介绍。珂朵莉树 (ChthollyTree) ，又名 OldDriverTree (老司机树)，简称 ODT ，是一种非常暴力的数据结构，它将一段值相同的区间以三元组 &lt; 左端点，右端点，值 &gt; 的方式存储起来，因此它的效率是建立在区间推平操作 (assign) 上的(也就是本题的砍树)。二、存储方式。珂朵莉树的存储基于平衡树(我这里为了方便用了 STL 的 set )，这里定义珂朵莉树的结点为：1234567struct node &#123; int l,r,v; node(int L,int R=-1,int V=0):l(L),r(R),v(V) &#123;&#125; bool operator&lt;(const node&amp; x)const&#123; return l&lt;x.l; &#125;&#125;;这里的 l 和 r 是区间的左右端点(闭区间)，v 是该区间的值(表示这一区间内所有元素的值都是v)，然后是构造函数和重载运算符，这里重载成比较区间左端点。最后把区间扔进平衡树就行了：12set&lt;node&gt;s;typedef set&lt;node&gt;::iterator IT;三、核心操作。珂朵莉树的操作是基于一个核心操作 split 的，传入参数 pos 后，它能返回左端点值为 pos 的结点的迭代器，如果不存在这样的结点，它就会把包含 pos 的结点 &lt; l，r，v &gt; 拆成 &lt; l , pos-1 , v &gt; 和 &lt; pos , r , v &gt; ，然后返回后面这个结点的迭代器。先上代码：123456789IT split(int pos) &#123; IT it=s.lower_bound(node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; --it; int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v; s.erase(it); s.insert(node(L,pos-1,V)); return s.insert(node(pos,R,V)).first;&#125;一行行来看：1IT it=s.lower_bound(node(pos));lower_bound 是获取左端点大于等于 pos 的第一个结点。1if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it;如果这个结点的左端点正好是 pos ，我们就直接返回它。12--it;int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v;否则的话 —it 得到的就是包含 pos 的结点，我们用 L、R、V 储存它的左右端点和值。1s.erase(it);然后我们删掉这个结点。12s.insert(node(L,pos-1,V));return s.insert(node(pos,R,V)).first;最后我们插入两个新的结点，左右端点分别是 &lt; L、pos-1 &gt; 和 &lt; pos、R &gt; ，顺便返回后面这个结点的迭代器。这样我们就完成了 split 操作。四、区间推平。这是保证珂朵莉树复杂度不至于爆炸的重要操作，它能将一个区间内的值变得一样，本题的砍树就是区间赋值为 0 。先上代码：12345void assign(int l,int r,int v) &#123; IT itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;看上去十分的暴力，事实上珂朵莉树就是这么暴力的数据结构。稍微解释一下代码：1IT itl=split(l),itr=split(r+1);itl 指向的结点左端点为 l ，itr 指向的结点左端点为 r+1 。1s.erase(itl,itr);删去平衡树中 [ itl , itr ) 的结点(左闭右开区间)。1s.insert(node(l,r,v));直接插入一个 &lt; l , r &gt; ，值为v的区间。就是这么直接暴力！Upd：由于某些未知原因（珂学规定），珂朵莉树提取区间时需要先 split 右端点！五、其他操作。1. 初始化初始化操作就是直接插入，本题所有树默认都是种上的，全部赋值为 1 就行：1s.insert(node(0,l,1));2. 区间操作区间操作的话这里就以题目的求和为例，先上代码：1234567int sum(int l,int r) &#123; int _sum=0; IT itr=split(r+1),itl=split(l); for(;itl!=itr;++itl) _sum+=(itl-&gt;v)*((itl-&gt;r)-(itl-&gt;l)+1); return _sum;&#125;同样是非常的暴力，直接取出所有区间内的结点暴力求和就行了，其他的操作如区间加法乘法什么的也是一样的，取出结点遍历一遍就行。六、本题代码。最后放上本题AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;struct node &#123; int l,r,v; node(int L,int R=-1,int V=0):l(L),r(R),v(V) &#123;&#125; bool operator&lt;(const node&amp; x)const&#123; return l&lt;x.l; &#125;&#125;;int l,m,x,y,_sum;set&lt;node&gt;s;typedef set&lt;node&gt;::iterator IT;IT split(int pos) &#123; IT it=s.lower_bound(node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; --it; int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v; s.erase(it); s.insert(node(L,pos-1,V)); return s.insert(node(pos,R,V)).first;&#125;void remove(int l,int r) &#123; IT itl=split(l),itr=split(r+1); s.erase(itl,itr); s.insert(node(l,r,0));&#125;void sum() &#123; for(IT it=s.begin();it!=s.end();++it) _sum+=it-&gt;v*(it-&gt;r-it-&gt;l+1);&#125;int main() &#123; scanf("%d%d",&amp;l,&amp;m); s.insert(node(0,l,1)); for(int i=1;i&lt;=m;++i) &#123; scanf("%d%d",&amp;x,&amp;y); remove(x,y); &#125; sum(); printf("%d",_sum);&#125;七、总结珂朵莉树的效率建立在区间推平操作 (assign) 上，它能使结点数量快速减小从而保证时间复杂度，因此珂朵莉树十分容易被卡，不到万不得已还是得乖乖用别的数据结构，不过它的代码十分简单，考场上写不出别的数据结构时也是可以交一个珂朵莉树的。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
</search>
